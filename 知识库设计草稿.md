 > 草稿版本，用于讨论和迭代。以“月卡”业务为示例说明。  
  
---  
  
## 1. 背景与目标  
  
### 1.1 背景  
  
集团内存在多套业务系统和复杂的业务流程，例如：  
  
- C 端开月卡、续费月卡、绑定/解绑车牌  
- 停车进出、计费、支付、欠费与追缴  
- 后台运营、人工干预、批处理任务等  
  
目前业务知识主要存在于：  
  
- 个人经验与口口相传  
- 各个系统的代码中（Controller/Service/DAO）  
- 数据库表结构、配置文件、日志、调用链  
  
缺乏一个统一、结构化的“业务知识底座”，导致：  
  
- 新人/横向团队难以快速理解“一个业务到底是怎么走的”  
- 出现问题时排查路径不统一、依赖个人经验  
- 很难让 AI 在集团范围内稳定回答“业务过程 / 数据流转 / 如何排查”等问题  
  
### 1.2 目标  
  
建设一个**企业业务知识库**，形成一套分层的、可被 AI 利用的业务知识模型，使其能够：  
  
- 回答“业务视角”的问题：  
  - 例：C 端用户开一张月卡，整体流程是怎样的？经过哪些系统？  
  - 例：开卡失败了，常见失败原因有哪些？排查顺序是什么？  
- 理解业务过程中的**数据流转与落点**：  
  - 例：开卡成功后，哪些表会写入记录？月卡的状态如何演进？  
- 在此基础上，后续支持：  
  - 自动生成排查建议（Runbook）  
  - 自动生成部分业务文档  
  - 为内部 AI 助手提供高质量上下文（RAG + 工具调用）  
  
为了控制复杂度，采用“三层模型”：  
  
1. 高维度业务流程层（BusinessProcess）  
2. 能力层（BusinessCapability + BusinessEntity）  
3. 底层数据资源层（DataResource）  
  
---  
  
## 2. 总体设计概览  
  
### 2.1 核心思想  
  
- **业务流程层**：描述“对外可理解的业务场景”和其内部步骤顺序，例如：  
  - C 端开卡 → 步骤 1：校验身份 → 步骤 2：创建月卡 → 步骤 3：扣费 → 步骤 4：绑定车牌  
- **能力层**：抽象可复用的“业务能力/功能”，例如：  
  - `card.open`（开月卡）、`card.bind`（绑定车牌）、`payment.pay_for_card`（为月卡支付）  
  - 能力与业务实体（用户、月卡、订单等）之间有清晰的读写关系  
- **数据资源层**：描述能力背后实际读写的数据库表、缓存、消息队列等资源，例如：  
  - `member_db.user_card`、`billing_db.card_instance`、`redis://.../active_cards`、`pulsar://topic/month_card`  
  
三层之间通过 ID 和关系表关联：  
  
- 流程层的每一步步骤引用一个能力节点（capability_id）  
- 能力层通过关系表关联哪些业务实体、哪些数据资源  
- 数据资源层描述具体库表/缓存/MQ Topic 等  
  
### 2.2 人工与自动的分工  
  
- **人工负责**：  
  - 定义业务流程的骨架（BusinessProcess + 高层步骤）  
  - 定义能力的业务含义（BusinessCapability + 与 BusinessEntity 的关系）  
- **自动/半自动负责**：  
  - 从代码仓库、数据库 schema、日志/trace 中抽取：  
    - 能力 ↔ 代码实现（CapabilityImplementation）  
    - 能力 ↔ 数据资源（CapabilityDataAccess）  
    - 真实调用路径作为流程步骤候选（process mining）  
  
---  
  
## 3. 第一层：业务流程层（BusinessProcess）  
  
### 3.1 目标  
  
以“业务视角”描述 **一类场景** 的典型执行步骤，而不是某个具体请求实例。  
  
- 例：  
  - C 端开月卡  
  - C 端续费月卡  
  - C 端绑定车牌  
  - 后台删除月卡  
  - 后台充值月卡余额  
  
### 3.2 数据模型草稿  
  
#### 3.2.1 BusinessProcess（流程定义）  
  
```text  
BusinessProcess  
- process_id      string   主键，如: "c_open_card", "c_renew_card"  
- name           string   可读名称，如: "C端开卡"  
- channel        string   触发渠道，如: "app", "backend_admin", "job", "api", "event"  
- domain         string   所属业务域，如: "membership/month_card"  
- description    string   文字描述（人写）  
- entrypoints    json?    可选：入口列表，如接口路径/页面ID/事件名  
- version        int      版本号  
- is_active      bool     是否为当前生效版本  
- created_at     datetime  
- updated_at     datetime  
```  
  
说明：  
  
- `entrypoints` 示例：  
  - `["POST /api/v1/month_card/open", "PAGE:App.My.MonthCard.Open"]`  
- `domain` 用于按业务线分组，例如：  
  - `membership/month_card`, `parking/close_lot`, `parking/roadside`, `billing/arrears` 等  
  
#### 3.2.2 BusinessProcessStep（流程步骤）  
  
```text  
BusinessProcessStep  
- step_id        bigint    主键  
- process_id     string    外键 -> BusinessProcess.process_id- order_no       int       步骤顺序，如: 10, 20, 30  
- capability_id  string    外键 -> BusinessCapability.capability_id- name           string    步骤显示名称，如: "创建月卡实例"  
- is_optional    bool      是否可选  
- branch         string    分支标识，如: "main", "error", "compensation"  
- role           string    执行主体: "user", "system", "operator"  
- condition      string?   可选：执行条件的简要描述  
- created_at     datetime  
- updated_at     datetime  
```  
  
> 关键点：流程步骤本身不直接长成“功能”，而是引用能力层的 `capability_id`。  
  
### 3.3 示例：月卡相关流程  
  
#### 3.3.1 C 端开卡（c_open_card）  
  
```text  
BusinessProcess  
- process_id   = "c_open_card"  
- name         = "C端开卡"  
- channel      = "app"  
- domain       = "membership/month_card"  
- description  = "用户在C端App中开通一张月卡"  
```  
  
```text  
BusinessProcessStep  
1) step_id=..., process_id="c_open_card", order_no=10,  
   capability_id="user.verify_identity", name="校验用户身份", is_optional=true,  branch="main", role="system"  
  
2) step_id=..., process_id="c_open_card", order_no=20,  
   capability_id="card.open", name="创建月卡实例", is_optional=false, branch="main", role="system"  
  
3) step_id=..., process_id="c_open_card", order_no=30,  
   capability_id="payment.pay_for_card", name="支付月卡费用", is_optional=false, branch="main", role="system"  
  
4) step_id=..., process_id="c_open_card", order_no=40,  
   capability_id="card.bind", name="绑定车牌", is_optional=true, branch="main", role="system"  
```  
  
#### 3.3.2 C 端续费（c_renew_card）  
  
```text  
BusinessProcess  
- process_id   = "c_renew_card"  
- name         = "C端续费"  
- channel      = "app"  
- domain       = "membership/month_card"  
```  
  
```text  
BusinessProcessStep  
1) order_no=10, capability_id="card.query",  name="查询当前月卡状态"  
2) order_no=20, capability_id="card.renew",  name="续费月卡"  
3) order_no=30, capability_id="payment.pay_for_card", name="支付续费金额"  
```  
  
#### 3.3.3 后台删除（back_delete_card）  
  
```text  
BusinessProcess  
- process_id   = "back_delete_card"  
- name         = "后台删除月卡"  
- channel      = "backend_admin"  
- domain       = "membership/month_card"  
```  
  
```text  
BusinessProcessStep  
1) order_no=10, capability_id="card.query",  name="核对月卡及账务状态", role="operator"  
2) order_no=20, capability_id="card.delete", name="逻辑删除月卡",       role="system"  
```  
  
---  
  
## 4. 第二层：能力层（BusinessCapability & BusinessEntity）  
  
### 4.1 目标  
  
将“业务功能”抽象为稳定、可复用的能力节点，而不是跟某一个接口/页面绑定死。  
  
- 例如：`card.open` 这个能力既可以用于 C 端开卡，也可以用于后台补开卡流程。  
- 能力与“业务实体”之间有清晰的关系：创建/读取/更新/失效/关联等。  
  
### 4.2 数据模型草稿  
  
#### 4.2.1 BusinessEntity（业务实体）  
  
```text  
BusinessEntity  
- entity_id     string   主键，如: "card", "user", "plate", "payment_order", "recharge_record"  
- name          string   名称，如: "月卡", "用户", "车牌", "支付订单", "充值记录"  
- domain        string   所属领域，如: "membership", "billing", "parking"  
- description   string   描述  
- created_at    datetime  
- updated_at    datetime  
```  
  
#### 4.2.2 BusinessCapability（业务能力）  
  
```text  
BusinessCapability  
- capability_id string   主键，如: "card.query", "card.open", "card.renew",  
                            "card.bind", "card.unbind", "card.delete", "card.recharge"- domain        string   所属业务域，如: "membership/month_card"  
- name          string   可读名称，如: "查询月卡", "开卡", "续费", "绑定车牌"  
- description   string   高层说明（人写）  
- created_at    datetime  
- updated_at    datetime  
```  
  
#### 4.2.3 CapabilityEntityRelation（能力与实体关系）  
  
```text  
CapabilityEntityRelation  
- capability_id string   外键 -> BusinessCapability.capability_id- entity_id     string   外键 -> BusinessEntity.entity_id- action_type   string   枚举: "create", "read", "update", "delete", "expire",  
                          "associate", "disassociate"- comment       string   说明  
```  
  
示例：  
  
```text  
card.open:  
- (capability_id=card.open, entity_id=card,          action_type=create)  
- (capability_id=card.open, entity_id=payment_order, action_type=create)  
  
card.bind:  
- (capability_id=card.bind, entity_id=card,  action_type=update)  
- (capability_id=card.bind, entity_id=plate, action_type=associate)  
  
card.delete:  
- (capability_id=card.delete, entity_id=card, action_type=expire)  
```  
  
#### 4.2.4 CapabilityImplementation（能力与代码实现绑定）  
  
> 这部分主要由自动分析+少量人工校对生成。  
  
```text  
CapabilityImplementation  
- capability_id string   外键 -> BusinessCapability.capability_id- system        string   系统名，如: "member-service", "billing-service"  
- repo          string   代码仓库标识  
- entry_type    string   枚举: "http_endpoint", "rpc_method", "job", "event_handler"  
- entry_name    string   如: "POST /api/v1/card/open", "MemberService.OpenCard"  
- code_ref      string   可选: 文件路径 + 行号或符号名  
- created_at    datetime  
- updated_at    datetime  
```  
  
示例：  
  
```text  
(capability_id=card.open,  
 system="member-service", entry_type="http_endpoint", entry_name="POST /api/v1/card/open", code_ref="member-service/controllers/card_controller.py:open_card")```  
  
---  
  
## 5. 第三层：数据资源层（DataResource）  
  
### 5.1 目标  
  
抽象出“能力背后实际读写的技术资源”，统一管理：  
  
- 数据库表 / 视图  
- 缓存键空间（Redis 等）  
- 消息队列 Topic（Pulsar/Kafka 等）  
- 搜索索引  
  
### 5.2 数据模型草稿  
  
#### 5.2.1 DataResource（数据资源）  
```

```text  
DataResource  
- resource_id   string   主键  
- type          string   枚举: "db_table", "db_view", "redis_keyspace", "mq_topic", "index", ...  
- system        string   所属系统，如: "member-service", "billing-service"  
- location      string   资源定位，如:  
                           - "member_db.user_card"                           - "redis://host:port/db/active_cards"                           - "pulsar://topic/month_card"- entity_id     string?  可选，关联主要服务的 BusinessEntity- description   string   描述  
- created_at    datetime  
- updated_at    datetime  
```  
  
#### 5.2.2 CapabilityDataAccess（能力对数据资源的访问）  
  
```text  
CapabilityDataAccess  
- capability_id string   外键 -> BusinessCapability.capability_id- resource_id   string   外键 -> DataResource.resource_id- access_type   string   枚举: "read", "write", "publish", "subscribe", "cache_read", "cache_write"  
- access_pattern string? 可选: 主键查询/索引查询/全表扫描等简要说明  
- created_at    datetime  
- updated_at    datetime  
```  
  
示例：  
  
```text  
card.open:  
- 写 user_card 表 (member_db.user_card)- 写 card_instance 表 (billing_db.card_instance)- 写 支付订单表 (pay_db.pay_order)  
payment.pay_for_card:  
- 写 pay_db.pay_order- 写 accounting_db.ledger```  
  
通过这层关系，AI 可以回答：  
  
- “某个能力/流程会涉及哪些表/缓存/Topic？”  
- “月卡开通后，数据库里哪些地方会出现记录？”  
  
---  
  
## 6. 人工与自动的协同方式（数据收集阶段）  
  
### 6.1 第一层：业务流程  
  
- 人负责：  
  - 列出关键业务场景（process_id + name + channel + domain）  
  - 大致梳理每个流程的高层步骤顺序  
- 机器可辅助：  
  - 从前端埋点、网关日志、链路追踪中挖“典型调用路径”，作为 `BusinessProcessStep` 的候选。  
  - 让人只需做“确认/微调”，而不是从零写完整流程。  
  
### 6.2 第二层：能力层  
  
- 人负责：  
  - 定义业务实体（BusinessEntity）  
  - 定义核心能力（BusinessCapability）名称与含义  
  - 指出能力与实体的主要关系（create/read/update/...），至少先覆盖最重要的实体  
- 机器可辅助：  
  - 用 embedding + 关键字在代码仓库中搜索相关 controller/service/handler，将候选实现方法与能力绑定（CapabilityImplementation）。  
  - 后续根据 DAO/ORM/SQL 分析自动填充部分 CapabilityEntityRelation。  
  
### 6.3 第三层：数据资源层  
  
- 人负责：  
  - 建立 **系统 → 库 → 表** 的基础注册信息（可以从现有元数据管理工具导入）  
  - 为重要表标注对应的 BusinessEntity（例如 user_card → card/entity）  
- 机器可辅助：  
  - 静态分析代码中的 ORM/DAO/SQL，识别“哪个实现方法访问了哪些表/Redis/Topic”。  
  - 结合 CapabilityImplementation 自动写入 CapabilityDataAccess。  
  
---  
  
## 7. 整体示例：从问题到回答  
  
以“C端开卡失败，我怎么排查？”为例，知识库如何支持 AI：  
  
1. AI 根据问题中的关键词“C端开卡” → 在 `BusinessProcess` 中找到 `process_id = c_open_card`。  
2. 从 `BusinessProcessStep` 读取该流程的步骤链：  
   - `user.verify_identity` → `card.open` → `payment.pay_for_card` → `card.bind`（可选）  
3. 对每个 `capability_id`，在能力层获取：  
   - 涉及的 BusinessEntity（用户、月卡、支付订单）  
   - 涉及的 DataResource（user_card 表、pay_order 表等）  
4. AI 可以给出一个排查建议大纲：  
   - 第一步：检查网关/身份校验日志（user.verify_identity）  
   - 第二步：检查 member-service / user_card 表中是否生成月卡记录（card.open）  
   - 第三步：检查支付订单是否创建/支付成功（payment.pay_for_card）  
   - 第四步（如果用户反馈车牌无效）：检查 card.bind 是否成功执行，并查看绑定关系  
5. 后续可以在此基础上扩展 `ErrorPattern`/`DiagnosisHint` 表，沉淀常见错误模式与排查路径。  
  
---  
  
## 8. 后续可扩展方向  
  
- 为能力和流程增加 **错误模式（ErrorPattern）** 和 **排查提示（DiagnosisHint）**：  
  - 将日志中的错误信息聚类，挂到 capability/process 上，形成“常见问题”库。  
- 为流程支持 **版本管理与灰度**：  
  - 类似 API 版本，业务流程也会变更，需要记录版本与生效时间段。  
- 集成到内部 AI 助手：  
  - 对话层 → 检索三层模型 → 结合实时数据查询工具（日志/DB API） → 返回业务+数据+排查建议。  
- 与现有元数据/CMDB/架构图工具对接：  
  - 可以将 DataResource 与现有 CMDB 的资源订阅关系打通。  
  
---  
  
> 本文档为草稿设计，建议作为讨论基础，从一个小域（如会员&月卡）试点实现上述三层模型，并在实践中迭代字段与结构。"