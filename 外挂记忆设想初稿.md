# 外挂记忆系统设计文档

> 状态：初步设计 | 创建日期：2024-12-16

## 1. 背景与问题

### 1.1 当前痛点

在 `opdoc_qa` Agent 的运行过程中，工具调用（如 `search_yongce_docs`）会返回大量内容：

| 检索模式 | 预估返回量 | Token 消耗 |
|---------|-----------|-----------|
| mix/hybrid | ~5万字 | ~20K tokens |
| local | ~1.2万字 | ~5K tokens |
| naive | ~1.2万字 | ~5K tokens |

**问题**：
- 多轮对话中，工具结果累积导致上下文急剧膨胀
- 10轮对话可能消耗 50万+ tokens，远超模型上下文限制
- Token 成本高昂

### 1.2 设计目标

1. **降低 Token 消耗**：正常对话只消耗几千 token
2. **信息不丢失**：完整工具结果可追溯
3. **按需加载**：只在需要时加载历史工具结果
4. **实现简洁**：最小化对现有架构的改动

---

## 2. 核心设计思路

### 2.1 虚拟内存类比

类似操作系统的虚拟内存机制：

| 操作系统概念 | 外挂记忆设计 |
|-------------|-------------|
| RAM（主存） | 上下文窗口 |
| 磁盘（外存） | 数据库存储 |
| 页表 | UUID → 完整内容映射 |
| 缺页中断 | AI 调用加载工具 |
| 页面置换 | 用完即卸载 |

### 2.2 工作流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    上下文窗口（精简模式）                         │
├─────────────────────────────────────────────────────────────────┤
│ User: 永策Pro的权限管理怎么配置？                                │
│ Assistant: [调用 search_yongce_docs]                             │
│ Tool Result: 📎 [存档:uuid-001] 已检索52000字，摘要：权限管理... │  ← 占位符
│ Assistant: 权限管理配置步骤如下...                               │
│ ─────────────────────────────────────────────────────────────── │
│ User: 你之前说的配置步骤再详细说一下第三步                        │
│ → AI判断需要加载 uuid-001 → 调用 load_tool_history               │
└─────────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────────────────────────────────────────────────────┐
│                    上下文窗口（加载模式）                         │
├─────────────────────────────────────────────────────────────────┤
│ Tool Result: [uuid-001 完整内容 52000字]                         │  ← 加载完整
│ Assistant: 权限管理配置步骤如下...                               │
│ User: 你之前说的配置步骤再详细说一下第三步                        │
│ Assistant: 第三步详细说明...                                     │
└─────────────────────────────────────────────────────────────────┘
                                ↓
                    下一轮对话：恢复为占位符
```

---

## 3. 详细设计

### 3.1 存档阈值

```python
ARCHIVE_THRESHOLD = 10000  # 超过 1 万字的工具结果进行存档
```

### 3.2 占位符格式

```
📎 [工具结果存档: {uuid}]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
工具: {tool_name}
查询: {query_summary}
时间: {timestamp}
原始长度: {original_length}字
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
内容摘要:
{summary_200_chars}

主要来源:
- {source_1}
- {source_2}
- {source_3}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
如需查看完整内容，请调用 load_tool_history(uuid="{uuid}")
```

### 3.3 数据库表设计

```python
class ToolResultArchive(Base):
    """工具结果存档表"""
    __tablename__ = "tool_result_archive"
    
    # 主键
    uuid = Column(String(36), primary_key=True)
    
    # 关联信息
    conversation_id = Column(String(36), index=True)  # 会话ID
    thread_id = Column(String(36), index=True)        # 线程ID（可选）
    
    # 工具信息
    tool_name = Column(String(100))
    tool_input = Column(JSON)           # 原始输入参数
    
    # 内容
    query_summary = Column(String(500)) # 查询摘要
    result_summary = Column(Text)       # 结果摘要（200-500字）
    result_full = Column(Text)          # 完整结果
    result_length = Column(Integer)     # 原始字符数
    
    # 来源信息
    sources = Column(JSON)              # 来源文档列表
    
    # 时间戳
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # 可选：向量索引（用于语义搜索历史）
    # embedding = Column(Vector(1536))
```

### 3.4 核心类设计

```python
class ToolResultManager:
    """工具结果管理器"""
    
    ARCHIVE_THRESHOLD = 10000
    
    async def process_tool_result(
        self,
        tool_name: str,
        tool_input: dict,
        result: str,
        conversation_id: str
    ) -> str:
        """
        处理工具返回结果
        
        Returns:
            如果结果较短，返回原文
            如果结果较长，存档并返回占位符
        """
        pass
    
    async def load_tool_result(self, uuid: str) -> str:
        """加载完整的工具结果"""
        pass
    
    async def prepare_context(
        self,
        messages: list,
        load_uuids: list = None
    ) -> list:
        """
        准备上下文
        
        Args:
            messages: 原始消息列表
            load_uuids: 需要加载完整内容的 UUID 列表
            
        Returns:
            处理后的消息列表
        """
        pass
    
    async def restore_placeholders(self, messages: list) -> list:
        """将加载的完整内容恢复为占位符（用于下一轮）"""
        pass
```

### 3.5 AI 加载工具

```python
load_tool_history_schema = {
    "name": "load_tool_history",
    "description": """加载之前工具调用的完整结果。
    
使用场景：
- 用户询问之前讨论过的细节
- 需要回顾历史检索内容
- 用户说"之前"、"刚才"、"上次说的"等

注意：只在确实需要历史详情时调用，避免不必要的加载。""",
    "parameters": {
        "type": "object",
        "properties": {
            "uuid": {
                "type": "string",
                "description": "要加载的工具结果 UUID（从占位符中获取）"
            }
        },
        "required": ["uuid"]
    }
}
```

---

## 4. 触发加载的策略

### 4.1 方案对比

| 方案 | 实现复杂度 | 准确度 | 说明 |
|------|-----------|--------|------|
| **AI 自主判断** | 低 | 高 | 给 AI 提供加载工具，由 AI 决定何时调用 |
| **关键词触发** | 低 | 中 | 检测"之前"、"刚才"等关键词 |
| **语义相似度** | 中 | 高 | 计算用户问题与历史结果的相似度 |
| **混合策略** | 高 | 最高 | 结合多种方案 |

### 4.2 推荐方案：AI 自主判断

优点：
- 实现简单，只需添加一个工具
- AI 可以根据上下文语义判断
- 灵活性最高

Prompt 增强：
```
## 历史工具结果管理

对话中可能包含已存档的工具结果（显示为占位符格式）。
当用户询问之前讨论过的细节时，你可以调用 `load_tool_history` 加载完整内容。

判断依据：
- 用户明确提到"之前"、"刚才说的"、"上次"
- 用户追问之前回答中的具体细节
- 占位符中的摘要不足以回答用户问题
```

---

## 5. Token 消耗对比

假设场景：10轮对话，每轮调用一次工具，每次返回5万字

| 方案 | 第1轮 | 第5轮 | 第10轮 | 总消耗 |
|------|-------|-------|--------|--------|
| **当前（全量累积）** | 5万 | 25万❌ | 50万❌ | 溢出 |
| **外挂记忆（占位符）** | 5万 | ~8千 | ~1.5万 | ~10万 |
| **外挂记忆（加载1个历史）** | 5万 | ~5.8万 | ~5.5万 | ~20万 |

**节省比例**：约 80%+

---

## 6. 实现计划

### Phase 1：基础功能
- [ ] 创建数据库表 `tool_result_archive`
- [ ] 实现 `ToolResultManager` 核心类
- [ ] 修改 `chat_service.py` 集成存档逻辑

### Phase 2：加载机制
- [ ] 实现 `load_tool_history` 工具
- [ ] 修改 Agent 配置，添加加载工具
- [ ] 更新 System Prompt

### Phase 3：优化增强
- [ ] 添加摘要生成逻辑（可选用小模型）
- [ ] 实现语义搜索历史（向量索引）
- [ ] 部分加载（只加载相关段落）

---

## 7. 待讨论问题

1. **摘要生成**：使用主模型还是小模型？是否需要额外 API 调用？
2. **加载粒度**：是否支持部分加载（只加载相关段落）？
3. **跨会话复用**：历史存档是否可以在新会话中复用？
4. **清理策略**：存档数据保留多久？如何清理过期数据？
5. **前端展示**：是否在前端显示"已存档"状态？

---

## 8. 相关文件

- `backend/app/services/chat/chat_service.py` - 聊天服务主逻辑
- `backend/app/services/lightrag_service.py` - LightRAG 检索服务
- `backend/app/llm/langchain/configs.py` - Agent 配置和 Prompt
- `backend/app/llm/langchain/tools/opdoc.py` - opdoc 工具定义

---

## 附录：参考资料

- [MemGPT: Towards LLMs as Operating Systems](https://research.memgpt.ai/)
- [Letta: Agent Memory Design](https://www.letta.com/blog/agent-memory)
- [Deep Research Agents Architecture](https://arxiv.org/html/2506.18096v1)
