/**
 * ChatPage - 重构后的聊天页面
 * 
 * 将大量子组件和工具函数拆分到独立文件：
 * - types/chat.ts: 类型定义
 * - utils/chatUtils.ts: 工具函数
 * - components/chat/*: UI 组件
 */

import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react'
import { CheckCircleOutlined, LoadingOutlined } from '@ant-design/icons'
import {
  createChatClient,
  ChatClient,
  ToolCallInfo,
  fetchConversationHistory,
  fetchTestingHistory,
  generateConversationTitle,
  listConversations,
  deleteConversation,
  truncateConversation,
  createRegenerateClient,
  AgentType,
  fetchAgentTypes,
  fetchLogQueryOptions,
  LogQueryOption,
  FileAttachment,
  fetchTestingSessionStatus,
  TestingSessionStatus,
} from '../api/llm'
import { fetchIterations, fetchIssues, IterationInfo, IssueInfo } from '../api/coding'
import { UploadedFile } from '../api/files'
import { showWarning } from '../utils/message'
import { showConfirm } from '../utils/confirm'
import { useTypewriter } from '../hooks/useTypewriter'
import { useFileUpload } from '../hooks/useFileUpload'
import { useTestingTaskBoard, TestingWSMessage, PhaseId } from '../hooks/useTestingTaskBoard'
import '../styles/ChatPage.css'

// 导入拆分的类型
import {
  ToolSummaryInfo,
  DisplayMessage,
  ConversationSummary,
  ActiveToolInfo,
} from '../types/chat'

// 导入拆分的工具函数
import {
  generateToolSummary,
  convertRawMessagesToDisplay,
  groupConversations,
} from '../utils/chatUtils'

// 导入拆分的组件
import {
  WelcomeScreen,
  MessageItem,
  ConversationSidebar,
  AgentSelectorHeader,
  TestingTaskPanel,
  ChatInputArea,
} from '../components/chat'

// ==========================================
// Constants
// ==========================================

const TESTING_PROJECT_NAME = 'yongcepingtaipro2.0'
      <h1 className="welcome-title">{config.title}</h1>
      
      {/* 日志排查助手显示当前配置 */}
      {agentType === 'log_troubleshoot' && businessLine && (
        <div className="welcome-config">
          <span className="welcome-config-label">当前业务线：</span>
          <span className="welcome-config-value">{businessLine}</span>
          {businessLine === '私有化' && privateServer && (
            <>
              <span className="welcome-config-separator">·</span>
              <span className="welcome-config-label">私有化集团：</span>
              <span className="welcome-config-value">{privateServer}</span>
            </>
          )}
        </div>
      )}
      
      <p className="welcome-subtitle">{config.subtitle}</p>
    </div>
  )
}

// 3. 通用可展开内容组件（动态测量高度，实现平滑动画）
interface ExpandableContentProps {
  isExpanded: boolean
  className?: string
  children: React.ReactNode
}

const ExpandableContent: React.FC<ExpandableContentProps> = ({ isExpanded, className, children }) => {
  const contentRef = useRef<HTMLDivElement>(null)
  const [height, setHeight] = useState<number | 'auto'>(0)
  
  useEffect(() => {
    if (!contentRef.current) return
    
    if (isExpanded) {
      // 展开：测量实际高度
      const scrollHeight = contentRef.current.scrollHeight
      setHeight(scrollHeight)
      // 动画结束后设为 auto，允许内容动态变化
      const timer = setTimeout(() => setHeight('auto'), 300)
      return () => clearTimeout(timer)
    } else {
      // 收起：先设为当前高度（触发过渡），再设为 0
      const scrollHeight = contentRef.current.scrollHeight
      setHeight(scrollHeight)
      requestAnimationFrame(() => {
        requestAnimationFrame(() => setHeight(0))
      })
    }
  }, [isExpanded])
  
  return (
    <div
      ref={contentRef}
      className={`expandable-content ${className || ''}`}
      style={{
        height: height === 'auto' ? 'auto' : height,
        opacity: isExpanded ? 1 : 0,
        visibility: isExpanded || height !== 0 ? 'visible' : 'hidden',
      }}
    >
      {children}
    </div>
  )
}

// 3. 工具调用过程展示（单个调用，一个面板）
interface ToolProcessProps {
  name: string
  isActive: boolean
  inputSummary?: string   // 输入摘要，如 "关键词: 开卡"
  outputSummary?: string  // 输出摘要，如 "找到 3 个结果"
  elapsed?: number        // 耗时（秒）
}

const ToolProcess: React.FC<ToolProcessProps> = ({ name, isActive, inputSummary, outputSummary, elapsed }) => {
  const [isExpanded, setIsExpanded] = useState(false)
  
  if (!name) return null
  const prettyName = name.replace(/_/g, ' ')
  
  // 格式化耗时
  const formatElapsed = (seconds?: number) => {
    if (seconds === undefined) return ''
    if (seconds < 1) return `${Math.round(seconds * 1000)}ms`
    return `${seconds.toFixed(1)}s`
  }
  
  // 统一格式：calling tool: xxx / called tool: xxx
  let label: React.ReactNode
  if (isActive) {
    label = <span className="status-text">calling tool: {prettyName}</span>
  } else {
    const elapsedStr = formatElapsed(elapsed)
    const extras = [elapsedStr, outputSummary].filter(Boolean)
    const suffix = extras.length > 0 ? ` (${extras.join(' · ')})` : ''
    label = `called tool: ${prettyName}${suffix}`
  }

  // 只有完成后有摘要时才能展开
  const canExpand = !isActive && (inputSummary || outputSummary)

  return (
    <div className={`inline-expandable ${isExpanded ? 'expanded' : ''}`}>
      <span 
        className="inline-expandable-toggle" 
        onClick={() => canExpand && setIsExpanded(!isExpanded)}
        style={{ cursor: canExpand ? 'pointer' : 'default' }}
      >
        {label}
        {canExpand && <span className="inline-chevron">›</span>}
      </span>
      {canExpand && (
        <ExpandableContent isExpanded={isExpanded} className="inline-expandable-content">
          {inputSummary && (
            <div className="tool-summary-item">
              <span className="tool-summary-label">查询:</span> {inputSummary}
            </div>
          )}
          {outputSummary && (
            <div className="tool-summary-item">
              <span className="tool-summary-label">结果:</span> {outputSummary}
            </div>
          )}
        </ExpandableContent>
      )}
    </div>
  )
}

// 4. 批量工具调用展示组件（合并展示，但保持和单个工具一样的 UI 样式）
interface BatchToolItemInfo {
  toolId: number
  name: string
  isActive: boolean
  inputSummary?: string
  outputSummary?: string
  elapsed?: number
}

interface BatchToolProcessProps {
  batchId: number
  tools: BatchToolItemInfo[]
}

const BatchToolProcess: React.FC<BatchToolProcessProps> = ({ tools }) => {
  const [isExpanded, setIsExpanded] = useState(false)
  
  const activeCount = tools.filter(t => t.isActive).length
  const completedCount = tools.filter(t => !t.isActive).length
  const totalCount = tools.length
  const isActive = activeCount > 0
  
  // 计算最大耗时（并行执行以最长的为准）
  const maxElapsed = Math.max(...tools.map(t => t.elapsed ?? 0))
  const formatElapsed = (seconds: number) => {
    if (seconds === 0) return ''
    if (seconds < 1) return `${Math.round(seconds * 1000)}ms`
    return `${seconds.toFixed(1)}s`
  }
  
  // 统一格式：calling tool: xxx, yyy / called tool: xxx, yyy
  const toolNames = tools.map(t => t.name.replace(/_/g, ' ')).join(', ')
  let label: React.ReactNode
  if (isActive) {
    label = <span className="status-text">calling tool: {toolNames} ({completedCount}/{totalCount})</span>
  } else {
    const elapsedStr = formatElapsed(maxElapsed)
    const suffix = elapsedStr ? ` (${elapsedStr})` : ''
    label = `called tool: ${toolNames}${suffix}`
  }

  // 批量工具调用时始终可以展开（执行中也可以查看各工具状态）
  const canExpand = totalCount > 1

  return (
    <div className={`inline-expandable ${isExpanded ? 'expanded' : ''} ${isActive ? 'active' : ''}`}>
      <span 
        className="inline-expandable-toggle" 
        onClick={() => canExpand && setIsExpanded(!isExpanded)}
        style={{ cursor: canExpand ? 'pointer' : 'default' }}
      >
        {label}
        {canExpand && <span className="inline-chevron">›</span>}
      </span>
      {canExpand && (
        <ExpandableContent isExpanded={isExpanded} className="inline-expandable-content">
          {tools.map((tool, idx) => {
            const prettyName = tool.name.replace(/_/g, ' ')
            const elapsedStr = tool.elapsed ? (tool.elapsed < 1 ? `${Math.round(tool.elapsed * 1000)}ms` : `${tool.elapsed.toFixed(1)}s`) : ''
            return (
              <div key={`${tool.toolId}-${idx}`} className="tool-summary-item">
                {tool.isActive ? (
                  <span className="loading-dots">calling tool: {prettyName}</span>
                ) : (
                  <span>
                    <strong>{prettyName}</strong>
                    {tool.inputSummary && <> · <span className="tool-summary-label">查询:</span> {tool.inputSummary}</>}
                    {tool.outputSummary && <> · <span className="tool-summary-label">结果:</span> {tool.outputSummary}</>}
                    {elapsedStr && <> · {elapsedStr}</>}
                  </span>
                )}
              </div>
            )
          })}
        </ExpandableContent>
      )}
    </div>
  )
}

// 5. 内容段落类型定义
// 工具占位符格式: <!--TOOL:toolName--> 或 <!--TOOL:toolName|inputSummary|outputSummary-->

interface ContentSegment {
  type: 'think' | 'text' | 'tool'
  content: string  // think/text 的内容，或 tool 的名称
  startPos: number
  endPos: number
  isComplete?: boolean  // 仅 think 类型：标签是否已闭合
  isToolActive?: boolean  // 仅 tool 类型：是否正在执行
  inputSummary?: string   // 仅 tool 类型：输入摘要
  outputSummary?: string  // 仅 tool 类型：输出摘要
  toolId?: number         // 仅 tool 类型：工具占位符 ID
}

/**
 * 根据工具名称生成输入摘要和输出摘要（与后端 _generate_tool_summaries 保持一致）
 */
const generateToolSummary = (
  toolName: string, 
  toolInput: Record<string, unknown>, 
  toolOutput: string
): { input: string; output: string } => {
  let inputSummary = ''
  let outputSummary = ''
  
  // 尝试解析输出为 JSON
  let outputData: Record<string, unknown> | null = null
  try {
    outputData = JSON.parse(toolOutput)
  } catch {
    // 解析失败，保持 null
  }
  
  // ========== 搜索类工具 ==========
  if (['search_businesses', 'search_steps', 'search_implementations', 'search_data_resources'].includes(toolName)) {
    const query = String(toolInput.query || '')
    if (query) {
      inputSummary = `关键词: ${query}`
    }
    
    if (outputData) {
      if (Array.isArray(outputData.candidates)) {
        const count = outputData.candidates.length
        const total = typeof outputData.total_count === 'number' ? outputData.total_count : count
        if (count > 0) {
          outputSummary = `找到 ${count} 个结果` + (total > count ? ` (共 ${total} 个)` : '')
        } else {
          outputSummary = String(outputData.message || '未找到结果')
        }
      } else if (Array.isArray(outputData.results)) {
        const count = outputData.results.length
        outputSummary = count > 0 ? `找到 ${count} 个相关代码片段` : '未找到相关代码'
      } else if (outputData.error) {
        outputSummary = '查询失败'
      }
    }
  }
  
  // ========== 代码上下文搜索 ==========
  else if (toolName === 'search_code_context') {
    const workspace = String(toolInput.workspace || '')
    const query = String(toolInput.query || '')
    const parts: string[] = []
    if (workspace) {
      parts.push(`代码库: ${workspace}`)
    }
    if (query) {
      const displayQuery = query.length > 40 ? query.slice(0, 40) + '...' : query
      parts.push(`查询: ${displayQuery}`)
    }
    inputSummary = parts.join(' | ')
    
    if (outputData) {
      if (Array.isArray(outputData.content)) {
        const count = outputData.content.length
        outputSummary = count > 0 ? `找到 ${count} 个相关代码片段` : '未找到相关代码'
      } else if (outputData.error) {
        outputSummary = '查询失败'
      } else if (outputData.text) {
        outputSummary = '找到相关代码'
      } else {
        outputSummary = '执行完成'
      }
    }
  }
  
  // ========== 文件读取类工具 ==========
  else if (toolName === 'read_file') {
    const path = String(toolInput.path || '')
    if (path) {
      const filename = path.split('/').pop()?.split('\\').pop() || path
      inputSummary = `文件: ${filename}`
    }
    
    if (outputData) {
      if (typeof outputData.content === 'string') {
        const lines = outputData.content.split('\n').length
        outputSummary = `读取成功 (${lines} 行)`
      } else if (outputData.error) {
        outputSummary = '读取失败'
      }
    } else if (toolOutput && !toolOutput.startsWith('{')) {
      const lines = toolOutput.split('\n').length
      outputSummary = `读取成功 (${lines} 行)`
    }
  }
  
  else if (toolName === 'read_file_range') {
    const path = String(toolInput.path || '')
    const startLine = Number(toolInput.start_line || 0)
    const endLine = Number(toolInput.end_line || 0)
    if (path) {
      const filename = path.split('/').pop()?.split('\\').pop() || path
      inputSummary = `文件: ${filename} (L${startLine}-${endLine})`
    }
    
    if (toolOutput && !toolOutput.toLowerCase().includes('error')) {
      outputSummary = `读取成功 (${endLine - startLine + 1} 行)`
    } else {
      outputSummary = '读取失败'
    }
  }
  
  else if (toolName === 'list_directory') {
    const path = String(toolInput.path || '/')
    const depth = Number(toolInput.max_depth || 2)
    inputSummary = `目录: ${path}` + (depth !== 2 ? ` (深度 ${depth})` : '')
    
    if (outputData) {
      if (Array.isArray(outputData.entries)) {
        outputSummary = `列出 ${outputData.entries.length} 个条目`
      } else if (outputData.error) {
        outputSummary = '列出失败'
      }
    }
  }
  
  // ========== 上下文获取类工具 ==========
  else if (toolName === 'get_business_context') {
    const processIds = Array.isArray(toolInput.process_ids) ? toolInput.process_ids : []
    const count = processIds.length
    inputSummary = count > 1 ? `批量查询 ${count} 个业务` : `业务ID: ${String(processIds[0] || '').slice(0, 20)}`
    
    if (outputData?.results) {
      const total = typeof outputData.total === 'number' ? outputData.total : 0
      outputSummary = `获取 ${total} 个业务上下文`
    } else if (outputData?.error) {
      outputSummary = '获取失败'
    }
  }
  
  else if (toolName === 'get_implementation_context') {
    const implIds = Array.isArray(toolInput.impl_ids) ? toolInput.impl_ids : []
    const count = implIds.length
    inputSummary = count > 1 ? `批量查询 ${count} 个接口` : `接口ID: ${String(implIds[0] || '').slice(0, 20)}`
    
    if (outputData?.results) {
      const total = typeof outputData.total === 'number' ? outputData.total : 0
      outputSummary = `获取 ${total} 个接口上下文`
    } else if (outputData?.error) {
      outputSummary = '获取失败'
    }
  }
  
  else if (toolName === 'get_implementation_business_usages') {
    const implIds = Array.isArray(toolInput.impl_ids) ? toolInput.impl_ids : []
    const count = implIds.length
    inputSummary = count > 1 ? `批量查询 ${count} 个接口使用情况` : `接口ID: ${String(implIds[0] || '').slice(0, 20)}`
    
    if (outputData?.results) {
      const total = typeof outputData.total === 'number' ? outputData.total : 0
      outputSummary = `获取 ${total} 个接口的业务使用`
    } else if (outputData?.error) {
      outputSummary = '查询失败'
    }
  }
  
  else if (toolName === 'get_resource_context') {
    const resourceIds = Array.isArray(toolInput.resource_ids) ? toolInput.resource_ids : []
    const count = resourceIds.length
    inputSummary = count > 1 ? `批量查询 ${count} 个资源` : `资源ID: ${String(resourceIds[0] || '').slice(0, 20)}`
    
    if (outputData?.results) {
      const total = typeof outputData.total === 'number' ? outputData.total : 0
      outputSummary = `获取 ${total} 个资源上下文`
    } else if (outputData?.error) {
      outputSummary = '获取失败'
    }
  }
  
  else if (toolName === 'get_resource_business_usages') {
    const resourceIds = Array.isArray(toolInput.resource_ids) ? toolInput.resource_ids : []
    const count = resourceIds.length
    inputSummary = count > 1 ? `批量查询 ${count} 个资源使用情况` : `资源ID: ${String(resourceIds[0] || '').slice(0, 20)}`
    
    if (outputData?.results) {
      const total = typeof outputData.total === 'number' ? outputData.total : 0
      outputSummary = `获取 ${total} 个资源的业务使用`
    } else if (outputData?.error) {
      outputSummary = '查询失败'
    }
  }
  
  // ========== 图遍历类工具 ==========
  else if (toolName === 'get_neighbors') {
    const nodeIds = Array.isArray(toolInput.node_ids) ? toolInput.node_ids : []
    const depth = Number(toolInput.depth || 1)
    const count = nodeIds.length
    inputSummary = count > 1 ? `批量查询 ${count} 个节点邻居` : `节点: ${String(nodeIds[0] || '').slice(0, 20)}`
    if (depth > 1) {
      inputSummary += ` (深度 ${depth})`
    }
    
    if (outputData?.neighbors) {
      const neighborCount = Array.isArray(outputData.neighbors) ? outputData.neighbors.length : 0
      outputSummary = `找到 ${neighborCount} 个邻居节点`
    } else if (outputData?.error) {
      outputSummary = '查询失败'
    }
  }
  
  else if (toolName === 'get_path_between_entities') {
    inputSummary = '路径查询'
    
    if (outputData) {
      if (Array.isArray(outputData.path)) {
        outputSummary = `找到路径 (${outputData.path.length} 跳)`
      } else if (outputData.error || outputData.path === null) {
        outputSummary = '未找到路径'
      }
    }
  }
  
  // ========== 代码精确搜索 ==========
  else if (toolName === 'grep_code') {
    const pattern = String(toolInput.pattern || '')
    const workspace = String(toolInput.workspace || '')
    const filePattern = String(toolInput.file_pattern || '')
    
    const parts: string[] = []
    if (workspace) {
      parts.push(`代码库: ${workspace}`)
    }
    if (pattern) {
      const displayPattern = pattern.length > 30 ? pattern.slice(0, 30) + '...' : pattern
      parts.push(`搜索: ${displayPattern}`)
    }
    if (filePattern) {
      parts.push(`文件: ${filePattern}`)
    }
    inputSummary = parts.join(' | ')
    
    if (outputData) {
      if (Array.isArray(outputData.matches)) {
        const count = outputData.matches.length
        outputSummary = count > 0 ? `找到 ${count} 处匹配` : '未找到匹配'
      } else if (outputData.error) {
        outputSummary = '搜索失败'
      }
    }
  }
  
  // 默认处理
  if (!inputSummary && toolInput) {
    const firstKey = Object.keys(toolInput)[0]
    if (firstKey) {
      const firstVal = String(toolInput[firstKey])
      inputSummary = firstVal.length > 30 ? `${firstKey}: ${firstVal.slice(0, 30)}...` : `${firstKey}: ${firstVal}`
    }
  }
  
  if (!outputSummary) {
    if (outputData?.error) {
      outputSummary = '执行失败'
    } else if (toolOutput.length > 0) {
      outputSummary = '执行完成'
    } else {
      outputSummary = '无结果'
    }
  }
  
  return { input: inputSummary, output: outputSummary }
}

/**
 * 统一的消息转换函数：将后端原始消息转换为前端显示格式
 * 处理逻辑：
 * 1. 合并连续的assistant消息（模拟流式输出的累积效果）
 * 2. 在content中插入工具占位符（保持原始顺序）
 * 3. 生成toolSummaries（包含batch信息）
 */
const convertRawMessagesToDisplay = (
  rawMessages: RawHistoryMessage[],
  threadId: string
): { 
  messages: DisplayMessage[], 
  toolSummaries: Map<string, ToolSummaryInfo> 
} => {
  const display: DisplayMessage[] = []
  const globalToolSummaries = new Map<string, ToolSummaryInfo>()
  
  let globalToolId = 0
  let globalBatchId = 0
  let accumulatedContent = ''
  let accumulatedToolCalls: ToolCallInfo[] = []
  let accumulatedToolSummaries = new Map<string, ToolSummaryInfo>() // 当前消息的工具摘要
  let aiMessageStartIndex = -1

  const flushAIMessage = () => {
    if (aiMessageStartIndex === -1) return
    
    display.push({
      id: `assistant-${aiMessageStartIndex}-${threadId}`,
      role: 'assistant',
      content: accumulatedContent,
      toolCalls: accumulatedToolCalls.length > 0 ? accumulatedToolCalls : undefined,
      toolSummaries: accumulatedToolSummaries.size > 0 ? new Map(accumulatedToolSummaries) : undefined,
    })
    
    accumulatedContent = ''
    accumulatedToolCalls = []
    accumulatedToolSummaries = new Map()
    aiMessageStartIndex = -1
  }

  rawMessages.forEach((m, i) => {
    if (m.role === 'user') {
      flushAIMessage()
      
      display.push({
        id: `user-${i}-${threadId}`,
        role: 'user',
        content: m.content,
        attachments: m.attachments,  // 保留附件信息
      })
    } else if (m.role === 'assistant') {
      if (aiMessageStartIndex === -1) {
        aiMessageStartIndex = i
      }
      
      // 添加content
      if (m.content) {
        accumulatedContent += m.content
      }
      
      // 如果有工具调用，生成占位符并追加
      if (m.tool_calls && m.tool_calls.length > 0) {
        globalBatchId++
        const batchSize = m.tool_calls.length
        
        for (let idx = 0; idx < m.tool_calls.length; idx++) {
          const tc = m.tool_calls[idx]
          globalToolId++
          
          // 查找对应的 tool 返回消息
          let toolOutput = ''
          for (let j = i + 1; j < rawMessages.length; j++) {
            if (rawMessages[j].role === 'tool' && rawMessages[j].tool_name === tc.name) {
              toolOutput = rawMessages[j].content
              break
            }
          }
          
          // 使用与后端一致的摘要生成函数
          const { input: inputSummary, output: outputSummary } = generateToolSummary(
            tc.name,
            tc.args || {},
            toolOutput
          )
          
          const toolKey = `${tc.name}:${globalToolId}`
          const summaryInfo: ToolSummaryInfo = {
            input: inputSummary,
            output: outputSummary,
            batchId: batchSize > 1 ? globalBatchId : undefined,
            batchSize: batchSize > 1 ? batchSize : undefined,
            batchIndex: batchSize > 1 ? idx : undefined,
          }
          
          // 存入当前消息的摘要Map
          accumulatedToolSummaries.set(toolKey, summaryInfo)
          // 同时存入全局Map（保持向后兼容）
          globalToolSummaries.set(toolKey, summaryInfo)
          
          // 追加工具占位符（保持原始顺序）
          accumulatedContent += `<!--TOOL:${tc.name}:${globalToolId}-->`
          
          // 记录到toolCalls
          accumulatedToolCalls.push({
            name: tc.name,
            output_length: toolOutput.length,
          })
        }
      }
    }
    // tool消息跳过，已通过占位符展示
  })
  
  flushAIMessage()
  
  return { messages: display, toolSummaries: globalToolSummaries }
}

const parseContentSegments = (
  content: string, 
  currentToolName?: string,
  toolSummaries?: Map<string, {input: string, output: string}>
): ContentSegment[] => {
  const segments: ContentSegment[] = []
  const str = content || ''
  const len = str.length

  let i = 0
  let buffer = ''
  let bufferStart = 0
  let inThink = false
  let thinkStartPos = -1

  const flushTextBuffer = (endPos: number) => {
    if (!buffer) return
    const text = buffer.trim()
    if (text) {
      segments.push({
        type: 'text',
        content: text,
        startPos: bufferStart,
        endPos,
      })
    }
    buffer = ''
  }

  while (i < len) {
    // 工具占位符：无论是否在 think 块内，都将其视为一个硬边界
    if (str.startsWith('<!--TOOL:', i)) {
      // 如果当前在 think 中，先结束未闭合的 think 段
      // 遇到工具调用说明思考阶段已结束，标记为已完成（避免一直显示加载动画）
      if (inThink) {
        const raw = buffer
        const trimmed = raw.trim()
        if (trimmed) {
          segments.push({
            type: 'think',
            content: trimmed,
            startPos: thinkStartPos >= 0 ? thinkStartPos : bufferStart,
            endPos: i,
            isComplete: true,  // 工具调用开始 = 思考结束
          })
        }
        inThink = false
        buffer = ''
      } else {
        // 不在 think 中则先 flush 之前累积的正文
        flushTextBuffer(i)
      }

      const end = str.indexOf('-->', i)
      if (end === -1) {
        // 工具标签尚未完整输出，作为普通文本暂存，等待后续内容
        bufferStart = i
        buffer += str.slice(i)
        break
      }

      const markerStart = i
      const markerEnd = end + 3
      const inner = str.slice(i + '<!--TOOL:'.length, end)

      let toolName = ''
      let toolId = ''
      const firstColon = inner.indexOf(':')
      if (firstColon === -1) {
        toolName = inner.trim()
      } else {
        toolName = inner.slice(0, firstColon).trim()
        toolId = inner.slice(firstColon + 1).trim()
      }

      const toolIdNum = toolId ? parseInt(toolId, 10) : undefined
      const toolKey = toolName && toolId ? `${toolName}:${toolId}` : undefined
      const summary = toolKey ? toolSummaries?.get(toolKey) : undefined

      segments.push({
        type: 'tool',
        content: toolName,
        startPos: markerStart,
        endPos: markerEnd,
        isToolActive: false, // 稍后根据 currentToolName 单独标记
        inputSummary: summary?.input,
        outputSummary: summary?.output,
        toolId: toolIdNum,
      })

      i = markerEnd
      bufferStart = i
      buffer = ''
      continue
    }

    // 解析 <think> 开始标签
    if (!inThink && str.startsWith('<think>', i)) {
      // 先 flush 之前的正文
      flushTextBuffer(i)

      inThink = true
      thinkStartPos = i
      i += '<think>'.length
      bufferStart = i
      buffer = ''
      continue
    }

    // 解析 </think> 结束标签
    if (inThink && str.startsWith('</think>', i)) {
      const raw = buffer
      const trimmed = raw.trim()
      if (trimmed) {
        segments.push({
          type: 'think',
          content: trimmed,
          startPos: thinkStartPos,
          endPos: i + '</think>'.length,
          isComplete: true,
        })
      }

      inThink = false
      i += '</think>'.length
      bufferStart = i
      buffer = ''
      continue
    }

    // 普通字符累积到 buffer
    if (!buffer) {
      bufferStart = i
    }
    buffer += str[i]
    i += 1
  }

  // 处理剩余缓冲区内容
  if (buffer) {
    if (inThink) {
      const trimmed = buffer.trim()
      if (trimmed) {
        segments.push({
          type: 'think',
          content: trimmed,
          startPos: thinkStartPos >= 0 ? thinkStartPos : bufferStart,
          endPos: len,
          isComplete: false,
        })
      }
    } else {
      flushTextBuffer(len)
    }
  }

  // 第二遍：根据 currentToolName 标记当前正在执行的工具
  if (currentToolName) {
    let activeIndex = -1
    for (let idx = 0; idx < segments.length; idx++) {
      const seg = segments[idx]
      if (seg.type === 'tool' && seg.content === currentToolName) {
        const hasSummary = !!(seg.inputSummary || seg.outputSummary)
        if (!hasSummary) {
          activeIndex = idx
        }
      }
    }
    if (activeIndex !== -1) {
      segments[activeIndex].isToolActive = true
    }
  }

  return segments
}

// 4. 思考过程展示组件（Cursor 风格：Thought for Xs）
interface ThinkBlockProps {
  content: string
  isStreaming?: boolean
  isComplete?: boolean  // think 标签是否已关闭
}

const ThinkBlock: React.FC<ThinkBlockProps> = ({ content, isStreaming, isComplete }) => {
  const [isExpanded, setIsExpanded] = useState(true)  // 默认展开
  const [userToggled, setUserToggled] = useState(false)
  const [durationMs, setDurationMs] = useState<number | null>(null)
  const thinkStartRef = useRef<number | null>(null)
  
  // 自动收起：think 完成后收起
  useEffect(() => {
    if (userToggled) return
    if (isComplete) {
      setIsExpanded(false)
    }
  }, [isComplete, userToggled])

  // 记录思考耗时：isStreaming 从 false -> true 记开始，完成时计算总时长
  useEffect(() => {
    if (isStreaming && thinkStartRef.current === null) {
      thinkStartRef.current = performance.now()
    }
    if (!isStreaming && isComplete && thinkStartRef.current !== null && durationMs === null) {
      const end = performance.now()
      setDurationMs(end - thinkStartRef.current)
    }
  }, [isStreaming, isComplete, durationMs])
  
  const handleToggle = () => {
    setUserToggled(true)
    setIsExpanded(!isExpanded)
  }
  
  if (!content) return null
  
  let title: React.ReactNode
  if (isStreaming) {
    title = <span className="status-text">Thinking</span>
  } else if (durationMs !== null) {
    const seconds = Math.max(0.1, durationMs / 1000)
    title = `Thought for ${seconds.toFixed(1)}s`
  } else {
    title = 'Thought'
  }
  
  return (
    <div className={`inline-expandable ${isExpanded ? 'expanded' : ''}`}>
      <span className="inline-expandable-toggle" onClick={handleToggle}>
        {title}
        <span className="inline-chevron">›</span>
      </span>
      <ExpandableContent isExpanded={isExpanded} className="inline-expandable-content think-text markdown-body">
        <MemoizedMarkdown source={content} fontSize={14} />
      </ExpandableContent>
    </div>
  )
}

// 6. 消息气泡
interface MessageItemProps {
  message: DisplayMessage
  isLoading?: boolean
  canRegenerate?: boolean  // 是否可以重新生成（非最后一条正在生成的消息）
  onRegenerate?: () => void
  onRollback?: () => void
  toolSummaries?: Map<string, ToolSummaryInfo>  // 工具摘要（包含批次信息）
  activeTools?: Map<number, ActiveToolInfo>     // 活跃工具信息（用于批次分组）
  activeToolsRef?: React.MutableRefObject<Map<number, ActiveToolInfo>>  // ref版本，用于同步获取
}

// 活跃工具信息（包含批次信息）
interface ActiveToolInfo {
  toolId: number
  batchId?: number
  batchSize?: number
  batchIndex?: number
}

// 渲染项类型：用于交错排列思考、工具、正文、批量工具
interface RenderItem {
  type: 'think' | 'tool' | 'text' | 'batch_tool'
  key: string
  // think 类型
  thinkContent?: string
  isThinkStreaming?: boolean
  isThinkComplete?: boolean
  // tool 类型（单个工具）
  toolName?: string
  toolId?: number
  toolIsActive?: boolean
  toolInputSummary?: string
  toolOutputSummary?: string
  toolElapsed?: number
  // batch_tool 类型（批量工具）
  batchId?: number
  batchTools?: BatchToolItemInfo[]
  // text 类型
  textContent?: string
}

/**
 * 构建交错渲染列表
 * 直接从 parseContentSegments 的结果构建，工具占位符已嵌入 content
 * 支持将同一批次的工具调用合并为 batch_tool 类型
 */
const buildRenderItems = (
  content: string,
  currentToolName?: string,
  toolSummaries?: Map<string, ToolSummaryInfo>,
  activeTools?: Map<number, ActiveToolInfo>,  // toolId -> 活跃工具信息
  activeToolsRef?: React.MutableRefObject<Map<number, ActiveToolInfo>>  // ref版本，用于同步获取最新值
): RenderItem[] => {
  const segments = parseContentSegments(content, currentToolName, toolSummaries)
  
  const result: RenderItem[] = []
  let i = 0
  
  while (i < segments.length) {
    const seg = segments[i]
    
    if (seg.type === 'think') {
      result.push({
        type: 'think' as const,
        key: `think-${i}-${seg.startPos}`,
        thinkContent: seg.content,
        isThinkStreaming: !seg.isComplete,
        isThinkComplete: seg.isComplete
      })
      i++
    } else if (seg.type === 'tool') {
      // 获取该工具的批次信息（优先从ref获取，确保最新）
      const toolKey = seg.toolId ? `${seg.content}:${seg.toolId}` : undefined
      const summary = toolKey ? toolSummaries?.get(toolKey) : undefined
      const activeInfo = seg.toolId ? (activeToolsRef?.current.get(seg.toolId) || activeTools?.get(seg.toolId)) : undefined
      
      const batchId = summary?.batchId ?? activeInfo?.batchId
      const batchSize = summary?.batchSize ?? activeInfo?.batchSize ?? 1
      
      // 如果是批量调用（batchSize > 1），收集同一批次的所有工具
      if (batchSize > 1 && batchId !== undefined) {
        const batchTools: BatchToolItemInfo[] = []
        const batchStartIdx = i
        
        // 收集连续的同批次工具
        while (i < segments.length && segments[i].type === 'tool') {
          const toolSeg = segments[i]
          const tk = toolSeg.toolId ? `${toolSeg.content}:${toolSeg.toolId}` : undefined
          const ts = tk ? toolSummaries?.get(tk) : undefined
          const ai = toolSeg.toolId ? activeTools?.get(toolSeg.toolId) : undefined
          
          const thisBatchId = ts?.batchId ?? ai?.batchId
          
          // 如果不是同一批次，停止收集
          if (thisBatchId !== batchId) break
          
          // 判断是否活跃：activeTools 中存在则为活跃，或者 toolSummaries 中无 output 也视为活跃
          const isToolActive = ai !== undefined || (!!toolSeg.isToolActive && !ts?.output)
          
          batchTools.push({
            toolId: toolSeg.toolId || 0,
            name: toolSeg.content,
            isActive: isToolActive,
            inputSummary: ts?.input || toolSeg.inputSummary,
            outputSummary: ts?.output || toolSeg.outputSummary,
            elapsed: ts?.elapsed,
          })
          i++
        }
        
        result.push({
          type: 'batch_tool' as const,
          key: `batch-${batchId}-${batchStartIdx}`,
          batchId,
          batchTools,
        })
      } else {
        // 单个工具调用 - 使用与批量工具相同的活跃状态判断逻辑
        const singleToolActive = activeInfo !== undefined || (!!seg.isToolActive && !summary?.output)
        
        result.push({
          type: 'tool' as const,
          key: `tool-${i}-${seg.content}-${seg.toolId}`,
          toolName: seg.content,
          toolId: seg.toolId,
          toolIsActive: singleToolActive,
          toolInputSummary: summary?.input || seg.inputSummary,
          toolOutputSummary: summary?.output || seg.outputSummary,
          toolElapsed: summary?.elapsed,
        })
        i++
      }
    } else {
      result.push({
        type: 'text' as const,
        key: `text-${i}-${seg.startPos}`,
        textContent: seg.content
      })
      i++
    }
  }
  
  return result
}

const MessageItem: React.FC<MessageItemProps> = React.memo(({ message, isLoading, canRegenerate, onRegenerate, onRollback, toolSummaries, activeTools, activeToolsRef }) => {
  const isUser = message.role === 'user'
  
  // 用户消息使用 Markdown 渲染（和 AI 消息一致）
  if (isUser) {
    const imageAttachments = message.attachments?.filter(a => a.type === 'image') || []
    const otherAttachments = message.attachments?.filter(a => a.type !== 'image') || []
    
    return (
      <div className={`message-item user`}>
        <div className="message-header">
          <div className="avatar user">
            <UserOutlined />
          </div>
          <span className="role-name">You</span>
        </div>
        <div className="message-bubble-wrapper">
          <div className="message-bubble">
            {/* 显示图片附件 */}
            {imageAttachments.length > 0 && (
              <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px', marginBottom: message.content ? '8px' : 0 }}>
                {imageAttachments.map(att => (
                  <Image
                    key={att.file_id}
                    src={att.url}
                    width={120}
                    style={{ borderRadius: '8px', objectFit: 'cover' }}
                    preview={{ mask: <div style={{ fontSize: 11 }}>预览</div> }}
                  />
                ))}
              </div>
            )}
            {/* 显示其他附件（文档等） */}
            {otherAttachments.length > 0 && (
              <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px', marginBottom: message.content ? '12px' : 0 }}>
                {otherAttachments.map(att => (
                  <FileAttachmentCard key={att.file_id} attachment={att} />
                ))}
              </div>
            )}
            {/* 消息文本 */}
            {message.content && <MemoizedMarkdown source={message.content} />}
          </div>
          {onRollback && !isLoading && (
            <div className="message-actions-external">
              <button className="action-btn" onClick={onRollback} title="回溯到此处，重新开始对话">
                <RollbackOutlined /> 回溯
              </button>
            </div>
          )}
        </div>
      </div>
    )
  }
  
  // Assistant 消息：直接调用 buildRenderItems，不使用 useMemo
  // 因为 Map 对象作为依赖项会导致每次都重新计算（每次 setState 创建新 Map）
  // buildRenderItems 本身不是重计算，真正的性能问题来自无限调用循环
  // 通过合理的组件设计避免无限循环，而不是依赖 useMemo
  // 优先使用消息自带的 toolSummaries（已完成的历史消息），否则使用 props 传入的全局 toolSummaries（当前正在流式输出）
  const effectiveToolSummaries = message.toolSummaries || toolSummaries
  const renderItems = buildRenderItems(message.content, message.currentToolName, effectiveToolSummaries, activeTools, activeToolsRef)
  
  // 初始思考状态：正在思考但还没有任何内容
  const isInitialThinking = message.isThinking && renderItems.length === 0
  
  // 检查是否有正文内容
  const hasTextContent = renderItems.some(item => item.type === 'text' && item.textContent)
  
  // 检查是否有工具调用
  const hasTools = renderItems.some(item => item.type === 'tool' || item.type === 'batch_tool')
  
  // 检查是否有任何工具正在执行（通过 renderItems 中的 isActive 状态判断）
  const hasActiveTools = renderItems.some(item => 
    (item.type === 'tool' && item.toolIsActive) ||
    (item.type === 'batch_tool' && item.batchTools?.some(t => t.isActive))
  )
  
  // 工具全部结束但正文尚未输出：有工具、无活跃工具、无当前工具名、无正文、isThinking
  const isWaitingMainAfterTools = hasTools && !hasActiveTools && !message.currentToolName && !hasTextContent && !!message.isThinking
  
  return (
    <div className={`message-item assistant`}>
      <div className="message-header">
        <div className="avatar assistant">
          <RobotOutlined />
        </div>
        <span className="role-name">Keytop AI</span>
      </div>
      
      <div className="message-bubble-wrapper">
        <div className="message-bubble">
          {/* 初始思考状态 */}
          {isInitialThinking && (
            <div className="inline-expandable">
              <span className="status-text">Thinking</span>
            </div>
          )}
          
          {/* 按顺序渲染所有内容 */}
          {renderItems.map(item => {
            if (item.type === 'think') {
              return (
                <ThinkBlock
                  key={item.key}
                  content={item.thinkContent || ''}
                  isStreaming={item.isThinkStreaming}
                  isComplete={item.isThinkComplete}
                />
              )
            }
            if (item.type === 'tool') {
              return (
                <ToolProcess
                  key={item.key}
                  name={item.toolName || ''}
                  isActive={item.toolIsActive || false}
                  inputSummary={item.toolInputSummary}
                  outputSummary={item.toolOutputSummary}
                  elapsed={item.toolElapsed}
                />
              )
            }
            if (item.type === 'batch_tool' && item.batchTools) {
              return (
                <BatchToolProcess
                  key={item.key}
                  batchId={item.batchId || 0}
                  tools={item.batchTools}
                />
              )
            }
            if (item.type === 'text') {
              return (
                <div key={item.key} className="markdown-body">
                  <MemoizedMarkdown source={item.textContent || ''} />
                </div>
              )
            }
            return null
          })}
          
          {/* 等待正文输出状态 */}
          {isWaitingMainAfterTools && (
            <div className="markdown-body">
              <span className="status-text">Answering</span>
            </div>
          )}
          
          {/* AI消息底部：重新回答按钮 */}
          {canRegenerate && !isLoading && hasTextContent && (
            <div className="message-actions">
              <button className="action-btn" onClick={onRegenerate} title="重新生成此回答">
                <ReloadOutlined /> 重新回答
              </button>
            </div>
          )}
        </div>
      </div>
    </div>
  )
})

// ==========================================
// Helper Functions
// ==========================================

// 将对话按时间分组
const groupConversations = (conversations: ConversationSummary[]): ConversationGroup[] => {
  const groups: { [key: string]: ConversationSummary[] } = {
    '今天': [],
    '本周': [],
  }
  
  // 用于存储月份的动态键
  const monthGroups: { [key: string]: ConversationSummary[] } = {}
  const monthOrder: string[] = [] // 保持月份顺序

  const now = new Date()
  const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime()
  const weekStart = todayStart - 6 * 24 * 60 * 60 * 1000 // 简单定义：过去7天内但不是今天

  conversations.forEach(conv => {
    const d = new Date(conv.updatedAt)
    const t = d.getTime()

    if (t >= todayStart) {
      groups['今天'].push(conv)
    } else if (t >= weekStart) {
      groups['本周'].push(conv)
    } else {
      // 使用英文月份名，如 November, October
      const monthName = d.toLocaleString('en-US', { month: 'long' })
      if (!monthGroups[monthName]) {
        monthGroups[monthName] = []
        // 如果是新出现的月份，记录顺序（其实应该按时间排序，这里简化处理，假设输入已经是倒序的）
        if (!monthOrder.includes(monthName)) {
          monthOrder.push(monthName)
        }
      }
      monthGroups[monthName].push(conv)
    }
  })

  // 构建最终数组
  const result: ConversationGroup[] = []
  
  if (groups['今天'].length > 0) result.push({ label: '今天', conversations: groups['今天'] })
  if (groups['本周'].length > 0) result.push({ label: '本周', conversations: groups['本周'] })
  
  monthOrder.forEach(m => {
    if (monthGroups[m].length > 0) {
      result.push({ label: m, conversations: monthGroups[m] })
    }
  })

  return result
}

// ==========================================
// Main Page Component
// ==========================================

const CONVERSATIONS_STORAGE_KEY = 'graph_chat_conversations_v1'

const ChatPage: React.FC = () => {
  const [messages, setMessages] = useState<DisplayMessage[]>([])
  const [inputValue, setInputValue] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const [isHistoryLoading, setIsHistoryLoading] = useState(false)  // 加载历史对话
  const [isConversationsLoading, setIsConversationsLoading] = useState(true)  // 加载会话列表
  const [threadId, setThreadId] = useState<string | null>(null)
  const [conversations, setConversations] = useState<ConversationSummary[]>([])
  const [activeConversationId, setActiveConversationId] = useState<string | null>(null)
  const [activeTab, setActiveTab] = useState<'chat' | 'voice' | 'imagine' | 'projects'>('chat')
  const [isSidebarCollapsed, setIsSidebarCollapsed] = useState(false)
  
  // Agent 类型状态
  const [agentTypes, setAgentTypes] = useState<AgentType[]>([])
  const [currentAgentType, setCurrentAgentType] = useState<string>('knowledge_qa')
  const [isAgentDropdownOpen, setIsAgentDropdownOpen] = useState(false)
  
  // 日志查询配置（仅 log_troubleshoot Agent 使用）
  const [businessLines, setBusinessLines] = useState<LogQueryOption[]>([])
  const [privateServers, setPrivateServers] = useState<LogQueryOption[]>([])
  const [businessLine, setBusinessLine] = useState<string>('')
  const [privateServer, setPrivateServer] = useState<string | null>(null)
  
  // 智能测试配置（仅 intelligent_testing Agent 使用）
  // 暂时硬编码项目名称
  const TESTING_PROJECT_NAME = 'yongcepingtaipro2.0'
  const [iterations, setIterations] = useState<IterationInfo[]>([])
  const [issues, setIssues] = useState<IssueInfo[]>([])
  const [selectedIteration, setSelectedIteration] = useState<IterationInfo | null>(null)
  const [selectedIssue, setSelectedIssue] = useState<IssueInfo | null>(null)
  const [iterationSearchText, setIterationSearchText] = useState('')
  const [issueSearchText, setIssueSearchText] = useState('')
  const [isIterationLoading, setIsIterationLoading] = useState(false)
  const [isIssueLoading, setIsIssueLoading] = useState(false)
  
  // 测试助手阶段管理（Tab 模式）
  const [testingSessionId, setTestingSessionId] = useState<string | null>(null)
  const [testingActivePhase, setTestingActivePhase] = useState<PhaseId>('analysis')
  const [testingSessionStatus, setTestingSessionStatus] = useState<TestingSessionStatus | null>(null)
  // 每个阶段独立的消息列表
  const [testingPhaseMessages, setTestingPhaseMessages] = useState<{
    analysis: DisplayMessage[]
    plan: DisplayMessage[]
    generate: DisplayMessage[]
  }>({ analysis: [], plan: [], generate: [] })
  
  // 下拉框展开状态
  const [isBusinessLineOpen, setIsBusinessLineOpen] = useState(false)
  const [isPrivateServerOpen, setIsPrivateServerOpen] = useState(false)
  const [isIterationOpen, setIsIterationOpen] = useState(false)
  const [isIssueOpen, setIsIssueOpen] = useState(false)
  
  // 文件工具弹窗状态
  const [isFileToolsOpen, setIsFileToolsOpen] = useState(false)
  
  // 智能测试任务看板 Hook
  const {
    tasks: testingTasks,
    phases: testingPhases,
    currentPhase: testingCurrentPhase,
    viewingPhase: testingViewingPhase,
    isRunning: isTestingRunning,
    handleMessage: handleTestingMessage,
    reset: resetTestingTaskBoard,
    restoreFromHistory: restoreTestingFromHistory,
    setViewingPhase: setTestingViewingPhase,
    setCurrentPhase: setTestingCurrentPhase,
    totalProgress: testingTotalProgress,
    currentPhaseInfo: testingCurrentPhaseInfo,
    viewingPhaseInfo: testingViewingPhaseInfo,
  } = useTestingTaskBoard()
  
  // 阶段总结弹窗状态
  const [summaryModalVisible, setSummaryModalVisible] = useState(false)
  const [summaryContent, setSummaryContent] = useState<string>('')
  const [summaryLoading, setSummaryLoading] = useState(false)
  
  // 切换业务线时，如果不是私有化则清空私有化选择
  const handleBusinessLineChange = (value: string) => {
    setBusinessLine(value)
    setIsBusinessLineOpen(false)
    if (value !== '私有化') {
      setPrivateServer(null)
    }
  }
  
  // 判断当前对话是否已有内容（用于锁定选择器）
  // - 测试助手：有 sessionId 且有状态
  // - 其他 Agent：有 threadId 且有消息
  const hasConversationContent = useMemo(() => {
    if (currentAgentType === 'intelligent_testing') {
      return !!testingSessionId && !!testingSessionStatus
    }
    return !!threadId && messages.length > 0
  }, [currentAgentType, testingSessionId, testingSessionStatus, threadId, messages.length])
  
  const handlePrivateServerChange = (value: string | null) => {
    setPrivateServer(value)
    setIsPrivateServerOpen(false)
  }
  
  // 实时状态
  const [currentTool, setCurrentTool] = useState<string | null>(null)
  const fullContentRef = useRef('') 
  const currentToolCallsRef = useRef<ToolCallInfo[]>([])
  const toolCallIdRef = useRef(0)  // 工具调用唯一 ID 计数器
  const currentToolIdRef = useRef(0)  // 当前正在执行的工具 ID
  // 工具摘要存储（使用 ref 避免频繁创建新 Map 触发重渲染）
  const toolSummariesRef = useRef<Map<string, ToolSummaryInfo>>(new Map())
  const [toolSummariesVersion, setToolSummariesVersion] = useState(0)
  // 提供给组件使用的稳定引用
  const toolSummaries = toolSummariesRef.current
  
  // 活跃工具存储（使用 ref）
  const activeToolsRef = useRef<Map<number, ActiveToolInfo>>(new Map())
  const [activeToolsVersion, setActiveToolsVersion] = useState(0)
  // 提供给组件使用的稳定引用
  const activeTools = activeToolsRef.current
  
  // 节流更新消息的 RAF ID
  const updateMessageRafRef = useRef<number | null>(null)
  const pendingContentRef = useRef<string>('')
  
  const chatClientRef = useRef<ChatClient | null>(null)
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const messageListRef = useRef<HTMLDivElement>(null)
  const phaseMessagesRef = useRef<Map<PhaseId, DisplayMessage[]>>(new Map())  // 缓存各阶段的消息
  const inputRef = useRef<HTMLTextAreaElement>(null)
  const userScrolledUpRef = useRef(false)
  const lastScrollTopRef = useRef(0)
  
  // 文件上传 Hook
  const { 
    uploadedFiles,
    pendingFiles,
    uploading, 
    handleUpload, 
    removeFile,
    removePendingFile,
    clearFiles,
    setFiles,
    enableDragDrop,
    enablePaste,
  } = useFileUpload()

  // 滚动到底部（只在用户未主动上滑时执行）
  const scrollToBottom = useCallback((force = false) => {
    if (!force && userScrolledUpRef.current) return
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }, [])

  // 检测用户是否滚动到底部附近
  const isNearBottom = useCallback(() => {
    const container = messageListRef.current
    if (!container) return true
    const threshold = 50 // 距离底部50px内认为在底部
    return container.scrollHeight - container.scrollTop - container.clientHeight < threshold
  }, [])

  // 监听滚动事件：检测滚动方向
  const handleScroll = useCallback(() => {
    const container = messageListRef.current
    if (!container) return
    
    const currentScrollTop = container.scrollTop
    const scrollingUp = currentScrollTop < lastScrollTopRef.current
    lastScrollTopRef.current = currentScrollTop
    
    if (isLoading) {
      if (scrollingUp && !isNearBottom()) {
        // 用户向上滚动且不在底部，标记为打断
        userScrolledUpRef.current = true
      } else if (isNearBottom()) {
        // 用户滚动回底部，恢复自动滚动
        userScrolledUpRef.current = false
      }
    }
  }, [isNearBottom, isLoading])

  // 打字机 Hook（使用默认速度配置）
  const { text: streamingContent, append: appendToTypewriter, finish: finishTypewriter, reset: resetTypewriter, isTyping, bufferLength } = useTypewriter({
    onTick: scrollToBottom,
  })
  
  // 缓冲区长度 ref（用于 setTimeout 回调中获取最新值）
  const bufferLengthRef = useRef(0)
  useEffect(() => {
    bufferLengthRef.current = bufferLength
  }, [bufferLength])

  // 加载本地存储的会话列表
  useEffect(() => {
    const loadConversations = async () => {
      setIsConversationsLoading(true)
      try {
        const data = await listConversations()
        const summaries: ConversationSummary[] = data.map(c => ({
          threadId: c.id,
          title: c.title || '新对话',
          agentType: c.agent_type,
          updatedAt: c.updated_at,
        }))
        setConversations(summaries)
      } catch (e) {
        console.error('加载会话列表失败', e)
      } finally {
        setIsConversationsLoading(false)
      }
    }
    loadConversations()
  }, [])
  
  // 加载 Agent 类型列表
  useEffect(() => {
    const loadAgentTypes = async () => {
      try {
        const types = await fetchAgentTypes()
        setAgentTypes(types)
        // 如果有可用类型且当前未设置，使用第一个作为默认
        if (types.length > 0 && !types.find(t => t.agent_type === currentAgentType)) {
          setCurrentAgentType(types[0].agent_type)
        }
      } catch (e) {
        console.error('加载 Agent 类型失败', e)
      }
    }
    loadAgentTypes()
  }, [])
  
  // 加载日志查询配置选项（仅在切换到日志排查 Agent 时加载）
  useEffect(() => {
    if (currentAgentType !== 'log_troubleshoot') return
    if (businessLines.length > 0) return  // 已加载过则不重复请求
    
    const loadLogQueryOptions = async () => {
      try {
        const options = await fetchLogQueryOptions()
        if (options?.businessLines) {
          setBusinessLines(options.businessLines)
          // 默认选中第一个业务线
          if (options.businessLines.length > 0) {
            setBusinessLine(options.businessLines[0].value)
          }
        }
        if (options?.privateServers) {
          setPrivateServers(options.privateServers)
        }
      } catch (e) {
        console.error('加载日志查询配置失败', e)
      }
    }
    loadLogQueryOptions()
  }, [currentAgentType])
  
  // 加载智能测试配置：迭代列表（仅在切换到智能测试 Agent 时加载）
  useEffect(() => {
    if (currentAgentType !== 'intelligent_testing') return
    if (iterations.length > 0) return  // 已加载过则不重复请求
    
    const loadIterations = async () => {
      setIsIterationLoading(true)
      try {
        const result = await fetchIterations(TESTING_PROJECT_NAME, 100, 0, '')
        if (result?.iterations) {
          setIterations(result.iterations)
        }
      } catch (e) {
        console.error('加载迭代列表失败', e)
      } finally {
        setIsIterationLoading(false)
      }
    }
    loadIterations()
  }, [currentAgentType])
  
  // 选择迭代后加载需求列表
  useEffect(() => {
    if (!selectedIteration) {
      setIssues([])
      setSelectedIssue(null)
      return
    }
    
    const loadIssues = async () => {
      setIsIssueLoading(true)
      setIssues([])
      setSelectedIssue(null)
      setIssueSearchText('')  // 切换迭代时清空搜索
      try {
        const result = await fetchIssues(TESTING_PROJECT_NAME, selectedIteration.code, 'REQUIREMENT', 100, 0, '')
        if (result?.issues) {
          setIssues(result.issues)
        }
      } catch (e) {
        console.error('加载需求列表失败', e)
      } finally {
        setIsIssueLoading(false)
      }
    }
    loadIssues()
  }, [selectedIteration])
  
  // 搜索迭代（后端查询）
  const handleSearchIterations = useCallback(async () => {
    setIsIterationLoading(true)
    try {
      const result = await fetchIterations(TESTING_PROJECT_NAME, 100, 0, iterationSearchText)
      if (result?.iterations) {
        setIterations(result.iterations)
      }
    } catch (e) {
      console.error('搜索迭代失败', e)
    } finally {
      setIsIterationLoading(false)
    }
  }, [iterationSearchText])
  
  // 搜索需求（后端查询）
  const handleSearchIssues = useCallback(async () => {
    if (!selectedIteration) return
    setIsIssueLoading(true)
    try {
      const result = await fetchIssues(TESTING_PROJECT_NAME, selectedIteration.code, 'REQUIREMENT', 100, 0, issueSearchText)
      if (result?.issues) {
        setIssues(result.issues)
      }
    } catch (e) {
      console.error('搜索需求失败', e)
    } finally {
      setIsIssueLoading(false)
    }
  }, [selectedIteration, issueSearchText])
  
  // 刷新测试任务状态
  const refreshTestingSessionStatus = useCallback(async () => {
    if (!testingSessionId) return
    try {
      const status = await fetchTestingSessionStatus(testingSessionId)
      setTestingSessionStatus(status)
    } catch (e) {
      console.error('刷新测试任务状态失败', e)
    }
  }, [testingSessionId])
  
  // 当 testingSessionId 变化时，刷新状态
  useEffect(() => {
    if (testingSessionId) {
      refreshTestingSessionStatus()
    }
  }, [testingSessionId, refreshTestingSessionStatus])
  
  // 切换 Agent 或新建对话时，重置测试阶段状态
  const resetTestingPhaseState = useCallback(() => {
    setTestingSessionId(null)
    setTestingActivePhase('analysis')
    setTestingSessionStatus(null)
    setTestingPhaseMessages({ analysis: [], plan: [], generate: [] })
  }, [])
  
  // 点击外部关闭下拉菜单
  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      const target = e.target as HTMLElement
      if (!target.closest('.agent-dropdown-wrapper')) {
        setIsAgentDropdownOpen(false)
      }
      if (!target.closest('.log-dropdown-wrapper')) {
        setIsBusinessLineOpen(false)
        setIsPrivateServerOpen(false)
      }
      if (!target.closest('.testing-dropdown-wrapper')) {
        setIsIterationOpen(false)
        setIsIssueOpen(false)
      }
      if (!target.closest('.file-tools-wrapper')) {
        setIsFileToolsOpen(false)
      }
    }
    if (isAgentDropdownOpen || isBusinessLineOpen || isPrivateServerOpen || isIterationOpen || isIssueOpen || isFileToolsOpen) {
      document.addEventListener('click', handleClickOutside)
      return () => document.removeEventListener('click', handleClickOutside)
    }
  }, [isAgentDropdownOpen, isBusinessLineOpen, isPrivateServerOpen, isIterationOpen, isIssueOpen, isFileToolsOpen])

  const upsertConversation = useCallback((tid: string, title: string, updatedAt: string, agentType?: string) => {
    if (!tid) return
    setConversations(prev => {
      const existing = prev.find(c => c.threadId === tid)
      const others = prev.filter(c => c.threadId !== tid)
      const item: ConversationSummary = {
        threadId: tid,
        title: title || existing?.title || '新对话',
        agentType: agentType || existing?.agentType,
        updatedAt,
      }
      return [item, ...others]
    })
  }, [])

  // 监听流式内容变化，节流更新消息（使用 RAF 避免过于频繁的重渲染）
  useEffect(() => {
    if (messages.length === 0 || (!isLoading && !isTyping)) return
    
    // 存储待更新的内容
    pendingContentRef.current = streamingContent
    
    // 如果已有 RAF 在等待，直接返回（节流）
    if (updateMessageRafRef.current !== null) return
    
    // 使用 RAF 进行节流更新
    updateMessageRafRef.current = requestAnimationFrame(() => {
      updateMessageRafRef.current = null
      const content = pendingContentRef.current
      
      // 查找正在加载的assistant消息（可能不是最后一条，比如regenerate时）
      setMessages(prev => {
        const newPrev = [...prev]
        let updated = false
        
        // 从后往前找第一个isThinking=true的assistant消息
        for (let i = newPrev.length - 1; i >= 0; i--) {
          if (newPrev[i].role === 'assistant' && newPrev[i].isThinking) {
            newPrev[i] = {
              ...newPrev[i],
              content: content,
            }
            updated = true
            break
          }
        }
        
        // 如果没找到isThinking的，更新最后一条assistant消息（兼容旧逻辑）
        if (!updated && isLoading) {
          const lastIdx = newPrev.length - 1
          if (lastIdx >= 0 && newPrev[lastIdx].role === 'assistant') {
            newPrev[lastIdx] = {
              ...newPrev[lastIdx],
              content: content,
            }
          }
        }
        
        return newPrev
      })
    })
    
    return () => {
      // 清理 RAF
      if (updateMessageRafRef.current !== null) {
        cancelAnimationFrame(updateMessageRafRef.current)
        updateMessageRafRef.current = null
      }
    }
  }, [streamingContent, isLoading, isTyping, messages.length])

  // 自动高度 textarea
  useEffect(() => {
    if (inputRef.current) {
      inputRef.current.style.height = 'auto'
      inputRef.current.style.height = Math.min(inputRef.current.scrollHeight, 200) + 'px'
    }
  }, [inputValue])
  
  // 启用拖拽和粘贴上传
  useEffect(() => {
    const cleanupDragDrop = enableDragDrop()
    const cleanupPaste = enablePaste()
    
    return () => {
      cleanupDragDrop()
      cleanupPaste()
    }
  }, [enableDragDrop, enablePaste])

  // 发送消息逻辑
  const sendMessage = useCallback(async (content?: string) => {
    const question = (content || inputValue).trim()
    
    // 允许无文本但有附件的情况
    if (!question && uploadedFiles.length === 0) return
    if (isLoading) return

    // 1. 添加 User 消息（包含附件）
    const userAttachments: FileAttachment[] = uploadedFiles.map(file => ({
      file_id: file.id,
      url: file.url,
      type: file.type as 'image' | 'document' | 'audio' | 'video' | 'unknown',
      filename: file.filename,
      content_type: file.contentType,
    }))
    
    const userMessage: DisplayMessage = {
      id: `user-${Date.now()}`,
      role: 'user',
      content: question || '请分析这些文件',
      attachments: userAttachments.length > 0 ? userAttachments : undefined,
    }
    
    // 2. 添加 Assistant 占位消息 (Loading 状态)
    const assistantMessageId = `assistant-${Date.now()}`
    const assistantMessage: DisplayMessage = {
      id: assistantMessageId,
      role: 'assistant',
      content: '',
      toolCalls: [],
      isThinking: true, // 初始状态为思考中
    }

    setMessages(prev => [...prev, userMessage, assistantMessage])
    setInputValue('')
    clearFiles()  // 清空附件列表
    setIsLoading(true)
    resetTypewriter()
    fullContentRef.current = ''
    currentToolCallsRef.current = []
    toolCallIdRef.current = 0  // 重置工具调用 ID 计数器
    // 清空工具状态（使用 ref.clear() 避免创建新 Map）
    toolSummariesRef.current.clear()
    activeToolsRef.current.clear()
    setToolSummariesVersion(v => v + 1)
    setActiveToolsVersion(v => v + 1)
    setCurrentTool(null)
    userScrolledUpRef.current = false
    
    // 发送消息后强制滚动到底部
    setTimeout(() => scrollToBottom(true), 50)

    // 3. 启动 WebSocket
    const client = createChatClient()
    chatClientRef.current = client

    // 构建请求参数
    const requestPayload: any = {
      question: question || '请分析这些文件',
      thread_id: threadId || undefined,
      agent_type: currentAgentType,
    }
    
    // 添加文件附件
    if (uploadedFiles.length > 0) {
      requestPayload.attachments = uploadedFiles.map(file => ({
        file_id: file.id,
        url: file.url,
        type: file.type,
        filename: file.filename,
        content_type: file.contentType,
      }))
    }
    
    // 日志排查 Agent 需要传递 log_query
    if (currentAgentType === 'log_troubleshoot') {
      requestPayload.log_query = {
        businessLine,
        privateServer: privateServer || null,
      }
    }
    
    // 需求分析测试助手需要传递 testing_context（使用阶段模式）
    if (currentAgentType === 'intelligent_testing') {
      // 已有会话时，使用会话中保存的需求信息
      if (testingSessionId && testingSessionStatus) {
        requestPayload.testing_context = {
          project_name: testingSessionStatus.project_name || TESTING_PROJECT_NAME,
          requirement_id: testingSessionStatus.requirement_id || '',
          requirement_name: testingSessionStatus.requirement_name || '',
          phase: testingActivePhase,
          session_id: testingSessionId,
        }
      } else if (selectedIssue) {
        // 新任务时，使用选择器中的需求信息
        requestPayload.testing_context = {
          project_name: TESTING_PROJECT_NAME,
          iteration_name: selectedIteration?.name || '',
          requirement_id: String(selectedIssue.code),
          requirement_name: selectedIssue.name,
          phase: testingActivePhase,
          session_id: undefined,
        }
      } else {
        // 没有选择需求时提示
        setIsLoading(false)
        setMessages(prev => prev.slice(0, -2))
        showWarning('请先在顶部配置栏中选择迭代和需求')
        return
      }
      // 不使用 threadId，而是使用阶段特定的 thread_id（由后端根据 phase 生成）
      delete requestPayload.thread_id
    }
    
    client.start(
      requestPayload,
      {
        onStart: (_rid, newThreadId) => {
          setThreadId(newThreadId)
          setActiveConversationId(newThreadId)
          
          // 智能测试 Agent: 处理 session_id
          if (currentAgentType === 'intelligent_testing' && newThreadId) {
            // thread_id 格式: {session_id}_{phase}，提取 session_id
            // 循环移除所有后缀（防止多层后缀）
            let sessionId = newThreadId
            while (sessionId.match(/_(analysis|plan|generate)$/)) {
              sessionId = sessionId.replace(/_(analysis|plan|generate)$/, '')
            }
            console.log('[Testing] onStart - newThreadId:', newThreadId, '提取的 sessionId:', sessionId)
            if (!testingSessionId) {
              setTestingSessionId(sessionId)
            }
            handleTestingMessage({ type: 'start', session_id: sessionId, phase: testingActivePhase })
            
            // 新任务时添加到历史列表，使用 session_id 而不是 thread_id
            if (!testingSessionId) {
              upsertConversation(sessionId, '新对话', new Date().toISOString(), currentAgentType)
            }
          } else {
            // 其他 Agent: 使用 thread_id
            const isNewConversation = !threadId
            if (isNewConversation && newThreadId) {
              upsertConversation(newThreadId, '新对话', new Date().toISOString(), currentAgentType)
            }
          }
        },
        
        onStream: (chunk) => {
          // 收到文本流
          fullContentRef.current += chunk
          appendToTypewriter(chunk)
          
          // 判断是否是真正的正文内容（不是think标签、不是工具占位符）
          const isRealContent = !chunk.includes('<think>') && 
                               !chunk.includes('</think>') && 
                               !chunk.includes('<!--TOOL:')
          
          // 只有在收到真正的正文时，才关闭thinking状态
          if (isRealContent && chunk.trim()) {
            setMessages(prev => {
               const newPrev = [...prev]
               const lastIdx = newPrev.length - 1
               if (lastIdx >= 0 && newPrev[lastIdx].id === assistantMessageId) {
                 newPrev[lastIdx].isThinking = false // 开始输出正文，停止纯思考动画
               }
               return newPrev
            })
          }
        },
        
        onToolStart: (name, toolInput, toolId, batch) => {
          // 不再插入占位符（后端已经通过 stream 发送了）
          // 只更新工具状态
          
          // 智能测试 Agent: 转发消息给任务看板 Hook
          if (currentAgentType === 'intelligent_testing') {
            handleTestingMessage({
              type: 'tool_start',
              tool_name: name,
              tool_id: toolId,
              tool_input: toolInput,
              batch_id: batch?.batchId,
              batch_size: batch?.batchSize,
              batch_index: batch?.batchIndex,
            })
          }
          
          // 记录当前工具 ID（用于 onToolEnd 时关联摘要）
          if (toolId) {
            currentToolIdRef.current = toolId
          } else {
            // 如果后端没有发 toolId，退化为计数器（兼容旧版本）
            toolCallIdRef.current += 1
            currentToolIdRef.current = toolCallIdRef.current
          }
          
          // 记录活跃工具的批次信息
          if (toolId && batch) {
            const toolInfo = {
              toolId,
              batchId: batch.batchId,
              batchSize: batch.batchSize,
              batchIndex: batch.batchIndex,
            }
            
            // 保存到 ref 并触发版本更新
            activeToolsRef.current.set(toolId, toolInfo)
            setActiveToolsVersion(v => v + 1)
          }
          
          setCurrentTool(name)
          
          // 更新消息状态：显示正在调用工具
          setMessages(prev => {
             const newPrev = [...prev]
             const lastIdx = newPrev.length - 1
             if (lastIdx >= 0 && newPrev[lastIdx].id === assistantMessageId) {
               newPrev[lastIdx].isThinking = true
               newPrev[lastIdx].currentToolName = name
             }
             return newPrev
          })
        },
        
        onToolEnd: (name, inputSummary, outputSummary, elapsed, toolId, batch) => {
          const finalToolId = toolId ?? currentToolIdRef.current
          
          // 智能测试 Agent: 转发消息给任务看板 Hook
          if (currentAgentType === 'intelligent_testing') {
            handleTestingMessage({
              type: 'tool_end',
              tool_name: name,
              tool_id: finalToolId,
              input_summary: inputSummary,
              output_summary: outputSummary,
              elapsed: elapsed,
              batch_id: batch?.batchId,
              batch_size: batch?.batchSize,
              batch_index: batch?.batchIndex,
            })
          }
          
          setCurrentTool(null)
          // 记录工具调用
          currentToolCallsRef.current.push({ name, output_length: 0 })
          
          // 把摘要存入 ref（包含批次信息和耗时）
          const toolKey = `${name}:${finalToolId}`
          toolSummariesRef.current.set(toolKey, { 
            input: inputSummary, 
            output: outputSummary,
            elapsed: elapsed,
            batchId: batch?.batchId,
            batchSize: batch?.batchSize,
            batchIndex: batch?.batchIndex,
          })
          setToolSummariesVersion(v => v + 1)
          
          // 从活跃工具中移除
          if (finalToolId) {
            activeToolsRef.current.delete(finalToolId)
            setActiveToolsVersion(v => v + 1)
          }
          
          setMessages(prev => {
             const newPrev = [...prev]
             const lastIdx = newPrev.length - 1
             if (lastIdx >= 0 && newPrev[lastIdx].id === assistantMessageId) {
               newPrev[lastIdx].toolCalls = [...currentToolCallsRef.current]
               newPrev[lastIdx].isThinking = true
               newPrev[lastIdx].currentToolName = undefined // 清除当前工具名
             }
             return newPrev
          })
        },
        
        // 智能测试 Agent: 阶段切换（只更新任务面板状态）
        // 注意：阶段分隔符现在由后端作为 stream 消息发送，嵌入到 assistant 消息内容中
        onPhaseChanged: (phase) => {
          if (currentAgentType === 'intelligent_testing') {
            handleTestingMessage({ type: 'phase_changed', phase })
          }
        },
        
        // 智能测试 Agent: 阶段完成（标记上一阶段已完成）
        onPhaseCompleted: (phase) => {
          if (currentAgentType === 'intelligent_testing') {
            handleTestingMessage({ type: 'phase_completed', phase })
          }
        },
        
        // 智能测试 Agent: 标题生成（在工作流开始时立即生成）
        onTitleGenerated: (title, tid) => {
          if (currentAgentType === 'intelligent_testing' && tid) {
            upsertConversation(tid, title, new Date().toISOString(), currentAgentType)
          }
        },
        
        onResult: (content, resultThreadId, toolCalls) => {
          // 最终结果 - 触发打字机加速清空缓冲区
          finishTypewriter()
          
          // 智能测试 Agent: 发送完成消息，同步消息到阶段列表
          if (currentAgentType === 'intelligent_testing') {
            handleTestingMessage({ type: 'result', status: 'completed' })
            // 刷新任务状态（检查是否有新的摘要保存）
            refreshTestingSessionStatus()
            // 同步消息到当前阶段
            setTestingPhaseMessages(prev => ({
              ...prev,
              [testingActivePhase]: messages,
            }))
          }
          
          // 快照当前工具摘要（后续会清空 ref，需要先复制一份）
          const snapshotToolSummaries = new Map(toolSummariesRef.current)
          
          // 更新元数据和状态（但不替换content，让打字机继续播放）
          setMessages(prev => {
            const newPrev = [...prev]
            const lastIdx = newPrev.findIndex(m => m.id === assistantMessageId)
            if (lastIdx !== -1) {
              newPrev[lastIdx] = {
                ...newPrev[lastIdx],
                toolCalls: toolCalls.length > 0 ? toolCalls : currentToolCallsRef.current,
                isThinking: false,
                toolSummaries: snapshotToolSummaries.size > 0 ? snapshotToolSummaries : undefined,
              }
            }
            return newPrev
          })
          
          setIsLoading(false)
          chatClientRef.current = null
          
          // 兜底：等待打字机真正完成后，确保内容完整
          const ensureComplete = () => {
            // 检查打字机缓冲区是否还有内容
            const bufferLen = bufferLengthRef.current
            if (bufferLen > 0) {
              // 打字机还在工作，等待后重试
              setTimeout(ensureComplete, 200)
              return
            }
            
            // 打字机已完成，确保内容一致
            setMessages(prev => {
              const newPrev = [...prev]
              const lastIdx = newPrev.findIndex(m => m.id === assistantMessageId)
              if (lastIdx !== -1) {
                const finalContent = fullContentRef.current || content
                // 只在内容不一致时更新（避免不必要的重渲染）
                if (newPrev[lastIdx].content !== finalContent) {
                  newPrev[lastIdx] = {
                    ...newPrev[lastIdx],
                    content: finalContent,
                  }
                }
              }
              return newPrev
            })
          }
          // 延迟 500ms 后开始检查（给打字机一点加速时间）
          setTimeout(ensureComplete, 500)
          
          // 延迟处理：生成对话标题（如果是新对话）
          // 注意：intelligent_testing agent 已在 onTitleGenerated 中处理，无需重复生成
          if (currentAgentType !== 'intelligent_testing') {
            setTimeout(() => {
              const finalThreadId = resultThreadId || threadId
              const isNewConversation = !threadId
              if (finalThreadId && isNewConversation) {
                generateConversationTitle(finalThreadId)
                  .then(title => {
                    upsertConversation(finalThreadId, title, new Date().toISOString(), currentAgentType)
                  })
                  .catch(e => console.warn('生成标题失败', e))
              }
            }, 200)
          }
        },
        
        onError: (err) => {
          console.error(err)
          finishTypewriter()
          
          // 智能测试 Agent: 发送错误消息
          if (currentAgentType === 'intelligent_testing') {
            handleTestingMessage({ type: 'error', error: String(err) })
          }
          
          // 更新最后一条 assistant 消息为错误状态，保留已有内容
          setMessages(prev => {
            const newPrev = [...prev]
            const lastIdx = newPrev.findIndex(m => m.id === assistantMessageId)
            if (lastIdx !== -1) {
              const existingContent = newPrev[lastIdx].content || ''
              newPrev[lastIdx] = {
                ...newPrev[lastIdx],
                content: existingContent + `\n\n⚠️ 发生错误: ${err}`,
                isThinking: false,
                currentToolName: undefined,
              }
            }
            return newPrev
          })
          setIsLoading(false)
          setCurrentTool(null)
          chatClientRef.current = null
        }
      }
    )
  }, [inputValue, isLoading, threadId, currentAgentType, businessLine, privateServer, selectedIssue, upsertConversation, appendToTypewriter, finishTypewriter, resetTypewriter, scrollToBottom, handleTestingMessage])

  const handleStop = () => {
    if (chatClientRef.current) {
      chatClientRef.current.stop()
      chatClientRef.current = null
    }
    setIsLoading(false)
    setMessages(prev => {
      const newPrev = [...prev]
      const lastMsg = newPrev[newPrev.length - 1]
      if (lastMsg.role === 'assistant') {
        newPrev[newPrev.length - 1] = {
          ...lastMsg,
          content: lastMsg.content + '\n\n[已停止生成]',
          isThinking: false
        }
      }
      return newPrev
    })
  }

  const handleClear = () => {
    setMessages([])
    setThreadId(null)
    setActiveConversationId(null)
    resetTypewriter()
    setInputValue('')
    // 重置智能测试任务面板
    resetTestingTaskBoard()
    // 重置测试阶段状态
    resetTestingPhaseState()
    // 清空阶段消息缓存
    phaseMessagesRef.current.clear()
    toolSummariesRef.current.clear()
  }

  // 精准重新生成指定 AI 回复（通过对应的用户消息索引）
  const handleRegenerate = useCallback((userMsgIndex: number) => {
    if (isLoading || !threadId) return
    
    // 找到对应的 assistant 消息位置（用于更新 UI）
    let userCount = 0
    let targetAssistantIdx = -1
    for (let i = 0; i < messages.length; i++) {
      if (messages[i].role === 'user') {
        if (userCount === userMsgIndex && i + 1 < messages.length && messages[i + 1].role === 'assistant') {
          targetAssistantIdx = i + 1
          break
        }
        userCount++
      }
    }
    if (targetAssistantIdx === -1) return
    
    // 设置目标 assistant 消息为加载状态
    setMessages(prev => prev.map((msg, idx) => 
      idx === targetAssistantIdx 
        ? { ...msg, content: '', isThinking: true, toolCalls: [], currentToolName: undefined }
        : msg
    ))
    setIsLoading(true)
    resetTypewriter()
    fullContentRef.current = ''
    currentToolCallsRef.current = []
    toolCallIdRef.current = 0  // 重置工具调用 ID 计数器
    // 清空工具状态
    toolSummariesRef.current.clear()
    activeToolsRef.current.clear()
    setToolSummariesVersion(v => v + 1)
    setActiveToolsVersion(v => v + 1)
    
    // 使用 RegenerateClient 调用后端
    const client = createRegenerateClient()
    
    client.start(
      { thread_id: threadId, user_msg_index: userMsgIndex, agent_type: currentAgentType },
      {
        onStream: (chunk) => {
          fullContentRef.current += chunk
          appendToTypewriter(chunk)
          
          // 判断是否是真正的正文内容（不是think标签、不是工具占位符）
          const isRealContent = !chunk.includes('<think>') && 
                               !chunk.includes('</think>') && 
                               !chunk.includes('<!--TOOL:')
          
          // 只有在收到真正的正文时，才关闭thinking状态
          if (isRealContent && chunk.trim()) {
            setMessages(prev => prev.map((msg, idx) => 
              idx === targetAssistantIdx 
                ? { ...msg, isThinking: false }
                : msg
            ))
          }
        },
        onToolStart: (name, _input, toolId) => {
          // 不再插入占位符（后端已经通过 stream 发送了）
          // 只更新工具状态
          
          // 记录当前工具 ID（用于 onToolEnd 时关联摘要）
          if (toolId) {
            currentToolIdRef.current = toolId
          } else {
            toolCallIdRef.current += 1
            currentToolIdRef.current = toolCallIdRef.current
          }
          
          setCurrentTool(name)
          setMessages(prev => prev.map((msg, idx) => 
            idx === targetAssistantIdx 
              ? { ...msg, isThinking: true, currentToolName: name }
              : msg
          ))
        },
        onToolEnd: (name, inputSummary, outputSummary, _elapsed) => {
          const toolId = currentToolIdRef.current
          setCurrentTool(null)
          currentToolCallsRef.current.push({ name, output_length: 0 })
          
          // 把摘要存入 ref
          const toolKey = `${name}:${toolId}`
          toolSummariesRef.current.set(toolKey, { input: inputSummary, output: outputSummary })
          setToolSummariesVersion(v => v + 1)
          
          setMessages(prev => prev.map((msg, idx) => 
            idx === targetAssistantIdx 
              ? { 
                  ...msg, 
                  toolCalls: [...currentToolCallsRef.current], 
                  isThinking: true, 
                  currentToolName: undefined 
                }
              : msg
          ))
        },
        onResult: (content, _threadId, toolCalls) => {
          // 触发打字机加速清空缓冲区
          finishTypewriter()
          
          // 快照当前工具摘要（后续会清空 ref，需要先复制一份）
          const snapshotToolSummaries = new Map(toolSummariesRef.current)
          
          // 更新元数据（但不替换content，让打字机继续播放）
          setMessages(prev => prev.map((msg, idx) => 
            idx === targetAssistantIdx 
              ? { 
                  ...msg, 
                  toolCalls: toolCalls.length > 0 ? toolCalls : currentToolCallsRef.current,
                  isThinking: false,
                  currentToolName: undefined,
                  toolSummaries: snapshotToolSummaries.size > 0 ? snapshotToolSummaries : undefined,
                }
              : msg
          ))
          
          setIsLoading(false)
          
          // 兜底：等待打字机真正完成后，确保内容完整
          const ensureComplete = () => {
            const bufferLen = bufferLengthRef.current
            if (bufferLen > 0) {
              setTimeout(ensureComplete, 200)
              return
            }
            setMessages(prev => prev.map((msg, idx) => {
              if (idx !== targetAssistantIdx) return msg
              const finalContent = fullContentRef.current || content
              if (msg.content !== finalContent) {
                return { ...msg, content: finalContent }
              }
              return msg
            }))
          }
          setTimeout(ensureComplete, 500)
        },
        onError: (err) => {
          console.error(err)
          finishTypewriter()
          // 保留已有内容，追加错误信息
          setMessages(prev => prev.map((msg, idx) => 
            idx === targetAssistantIdx 
              ? { ...msg, content: (msg.content || '') + `\n\n⚠️ 重新生成失败: ${err}`, isThinking: false, currentToolName: undefined }
              : msg
          ))
          setIsLoading(false)
          setCurrentTool(null)
        }
      }
    )
  }, [messages, isLoading, threadId, appendToTypewriter, finishTypewriter, resetTypewriter])

  // 回溯到某条用户消息（删除该消息及之后所有消息，将内容填充到输入框）
  const handleRollback = useCallback(async (messageId: string) => {
    if (isLoading) return
    
    const idx = messages.findIndex(m => m.id === messageId)
    if (idx === -1 || messages[idx].role !== 'user') return
    
    const userMessage = messages[idx]
    const userContent = userMessage.content
    const userAttachments = userMessage.attachments
    
    // 计算要保留的对话对数（该用户消息之前有多少个用户消息）
    let keepPairs = 0
    for (let i = 0; i < idx; i++) {
      if (messages[i].role === 'user') {
        keepPairs++
      }
    }
    
    // 调用后端 API 截断持久化的对话历史
    if (threadId) {
      try {
        await truncateConversation(threadId, keepPairs)
      } catch (e) {
        console.error('截断对话历史失败', e)
      }
    }
    
    // 删除该消息及之后的所有消息
    setMessages(prev => prev.slice(0, idx))
    // 将内容填充到输入框，让用户可以修改后发送
    setInputValue(userContent)
    // 恢复附件到输入框
    if (userAttachments && userAttachments.length > 0) {
      // 将 FileAttachment 转换为 UploadedFile 格式
      const restoredFiles = userAttachments.map(att => ({
        id: att.file_id || `restored-${Date.now()}-${Math.random().toString(36).slice(2)}`,
        url: att.url,
        filename: att.filename,
        size: 0,  // 历史记录中没有大小信息
        type: att.type as 'image' | 'document' | 'audio' | 'video' | 'unknown',
        contentType: att.content_type,
      }))
      setFiles(restoredFiles)
    } else {
      clearFiles()
    }
    // 聚焦输入框
    setTimeout(() => inputRef.current?.focus(), 50)
  }, [messages, isLoading, threadId, setFiles, clearFiles])

  const handleSelectConversation = useCallback(async (conv: ConversationSummary) => {
    if (!conv.threadId) return
    setActiveConversationId(conv.threadId)
    setThreadId(conv.threadId)
    // 恢复历史会话的 Agent 类型
    if (conv.agentType) {
      setCurrentAgentType(conv.agentType)
    }
    setIsHistoryLoading(true)
    setMessages([])  // 先清空，显示加载状态
    resetTypewriter()

    try {
      // 智能测试 Agent 使用专用 API 恢复历史
      if (conv.agentType === 'intelligent_testing') {
        // 设置 session_id（确保移除所有可能的 _phase 后缀）
        let sessionId = conv.threadId
        // 循环移除所有后缀（防止多层后缀如 xxx_generate_generate）
        while (sessionId.match(/_(analysis|plan|generate)$/)) {
          sessionId = sessionId.replace(/_(analysis|plan|generate)$/, '')
        }
        console.log('[Testing] 恢复历史 - conv.threadId:', conv.threadId, '提取的 sessionId:', sessionId)
        setTestingSessionId(sessionId)
        
        // 获取任务状态
        try {
          const status = await fetchTestingSessionStatus(sessionId)
          setTestingSessionStatus(status)
          
          // 确定初始显示的阶段（从最后一个有内容的阶段开始）
          let initialPhase: PhaseId = 'analysis'
          if (status.phases.generate.has_summary) {
            initialPhase = 'generate'
          } else if (status.phases.plan.has_summary) {
            initialPhase = 'plan'
          } else if (status.phases.analysis.has_summary) {
            initialPhase = 'plan'  // 分析完成，显示方案阶段
          }
          setTestingActivePhase(initialPhase)
          setTestingViewingPhase(initialPhase)
          
          // 预加载所有阶段的消息到缓存
          const phases: PhaseId[] = ['analysis', 'plan', 'generate']
          toolSummariesRef.current.clear()
          phaseMessagesRef.current.clear()  // 清空缓存，确保不会有脏数据
          
          console.log('[Testing] 开始预加载所有阶段消息, sessionId:', sessionId)
          for (const phase of phases) {
            try {
              const phaseThreadId = `${sessionId}_${phase}`
              console.log('[Testing] 加载阶段消息:', phase, 'threadId:', phaseThreadId)
              const rawMessages = await fetchConversationHistory(phaseThreadId)
              console.log('[Testing] 阶段', phase, '获取到消息数:', rawMessages.length)
              if (rawMessages.length > 0) {
                const result = convertRawMessagesToDisplay(rawMessages, phaseThreadId)
                phaseMessagesRef.current.set(phase, result.messages)
                console.log('[Testing] 阶段', phase, '转换后消息数:', result.messages.length)
                // 合并工具摘要
                result.toolSummaries.forEach((value, key) => {
                  toolSummariesRef.current.set(key, value)
                })
              }
            } catch (e) {
              console.log(`[Testing] 阶段 ${phase} 加载失败:`, e)
            }
          }
          console.log('[Testing] 预加载完成, 缓存内容:', 
            'analysis:', phaseMessagesRef.current.get('analysis')?.length || 0,
            'plan:', phaseMessagesRef.current.get('plan')?.length || 0,
            'generate:', phaseMessagesRef.current.get('generate')?.length || 0
          )
          
          setToolSummariesVersion(v => v + 1)
          
          // 显示初始阶段的消息
          const initialMessages = phaseMessagesRef.current.get(initialPhase) || []
          setMessages(initialMessages)
          
          // 获取任务历史并恢复任务面板状态
          const testingResult = await fetchTestingHistory(sessionId)
          restoreTestingFromHistory(
            {
              analysis: { completed: status.phases.analysis.has_summary },
              plan: { completed: status.phases.plan.has_summary },
              generate: { completed: status.phases.generate.has_summary },
            },
            status.current_phase,
            status.status,
            testingResult.task_history
          )
        } catch (e) {
          console.error('加载测试任务状态失败', e)
          // 回退到旧的恢复逻辑
          const testingResult = await fetchTestingHistory(sessionId)
          if (testingResult.phases) {
            restoreTestingFromHistory(
              testingResult.phases, 
              testingResult.current_phase, 
              testingResult.status,
              testingResult.task_history
            )
          }
          const result = convertRawMessagesToDisplay(testingResult.messages, sessionId)
          toolSummariesRef.current.clear()
          result.toolSummaries.forEach((value, key) => {
            toolSummariesRef.current.set(key, value)
          })
          setToolSummariesVersion(v => v + 1)
          setMessages(result.messages)
        }
      } else {
        // 其他 Agent 使用普通 API
        const rawMessages = await fetchConversationHistory(conv.threadId)
        
        // 使用统一的转换函数
        const result = convertRawMessagesToDisplay(rawMessages, conv.threadId)
        
        // 更新工具摘要 ref
        toolSummariesRef.current.clear()
        result.toolSummaries.forEach((value, key) => {
          toolSummariesRef.current.set(key, value)
        })
        setToolSummariesVersion(v => v + 1)
        setMessages(result.messages)
      }
      
      // 历史会话加载完成后，直接定位到底部（不使用动画）
      setTimeout(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'instant' })
      }, 50)
    } catch (e) {
      console.error('加载会话历史失败', e)
    } finally {
      setIsHistoryLoading(false)
    }
  }, [resetTypewriter, scrollToBottom, restoreTestingFromHistory])

  const handleDeleteConversation = async (e: React.MouseEvent, conv: ConversationSummary) => {
    e.stopPropagation()
    const confirmed = await showConfirm({
      title: '删除对话',
      content: '确定要删除该对话吗？删除后无法恢复。',
      okText: '删除',
      okType: 'primary',
      okButtonProps: { danger: true },
    })
    if (!confirmed) return

    try {
      await deleteConversation(conv.threadId)
      setConversations(prev => prev.filter(c => c.threadId !== conv.threadId))
      
      if (activeConversationId === conv.threadId) {
        handleClear()
      }
    } catch (err) {
      console.error('删除失败', err)
    }
  }

  const groupedConversations = groupConversations(conversations)

  return (
    <div className="chat-page-container">
      <div className={`chat-sidebar ${isSidebarCollapsed ? 'collapsed' : ''}`}>
        {/* 导航菜单 */}
        <div className="sidebar-menu">
          <div 
            className={`menu-item ${activeTab === 'chat' ? 'active' : ''}`}
            onClick={() => {
              setActiveTab('chat')
              handleClear() // 点击聊天通常意味着新对话
            }}
            title="新建聊天"
          >
            <EditOutlined className="menu-icon" />
            {!isSidebarCollapsed && <span className="menu-text">新建聊天</span>}
          </div>
        </div>

        {/* 历史记录列表 */}
        <div className="conversation-history-container">
          {isSidebarCollapsed ? (
            <div 
              className="menu-item" 
              onClick={() => setIsSidebarCollapsed(false)}
              title="查看历史记录"
            >
              <HistoryOutlined className="menu-icon" />
            </div>
          ) : (
            <>
              <div className="history-header">
                <HistoryOutlined className="history-icon" />
                <span className="history-title">历史记录</span>
              </div>
              
              <div className="conversation-list">
                {isConversationsLoading ? (
                  <div className="conversation-list-loading">
                    <LoadingOutlined spin />
                    <span>加载中...</span>
                  </div>
                ) : conversations.length === 0 ? (
                  <div className="conversation-list-empty">暂无历史</div>
                ) : (
                  groupedConversations.map(group => (
                    <div key={group.label} className="history-group">
                      <div className="history-group-label">{group.label}</div>
                      {group.conversations.map(conv => (
                        <div
                          key={conv.threadId}
                          className={`conversation-item ${conv.threadId === activeConversationId ? 'active' : ''} ${isHistoryLoading && conv.threadId === activeConversationId ? 'loading' : ''}`}
                          onClick={() => handleSelectConversation(conv)}
                          title={conv.title || '新对话'}
                        >
                          <div className="conversation-item-title">{conv.title || '新对话'}</div>
                          {isHistoryLoading && conv.threadId === activeConversationId ? (
                            <LoadingOutlined spin className="conversation-item-loading" />
                          ) : (
                            <div 
                               className="conversation-item-delete"
                               onClick={(e) => handleDeleteConversation(e, conv)}
                               title="删除对话"
                            >
                               <DeleteOutlined />
                            </div>
                          )}
                        </div>
                      ))}
                    </div>
                  ))
                )}
                
                {!isConversationsLoading && conversations.length > 0 && (
                   <div className="view-all-history">查看全部</div>
                )}
              </div>
            </>
          )}
        </div>
        
        {/* 底部折叠按钮 */}
        <div className="sidebar-footer">
          <div 
            className="sidebar-collapse-btn" 
            onClick={() => setIsSidebarCollapsed(!isSidebarCollapsed)}
            title={isSidebarCollapsed ? "展开侧边栏" : "收起侧边栏"}
          >
            {isSidebarCollapsed ? <MenuUnfoldOutlined /> : <MenuFoldOutlined />}
          </div>
        </div>
      </div>

      {/* 智能测试任务看板面板 - 仅 intelligent_testing Agent 显示 */}
      {currentAgentType === 'intelligent_testing' && (
        <div className="testing-task-panel">
          <div className="testing-panel-header">
            <span className="testing-panel-header-icon">📋</span>
            任务追踪看板
          </div>
          
          {/* 阶段选择器 - 点击切换阶段和对话 */}
          <div className="testing-phase-tabs">
            {testingPhases.map((phase) => {
              const isActive = testingActivePhase === phase.id
              const isCurrent = testingCurrentPhase === phase.id
              const isCompleted = phase.status === 'completed'
              return (
                <div 
                  key={phase.id}
                  className={`testing-phase-tab ${isActive ? 'active' : ''} ${isCompleted ? 'completed' : ''} ${isCurrent && isTestingRunning ? 'running' : ''}`}
                  onClick={async () => {
                    // 如果正在生成中，禁止切换阶段
                    if (isLoading) {
                      showWarning('AI 正在生成中，请等待完成后再切换阶段')
                      return
                    }
                    
                    // 保存当前阶段的消息到缓存
                    phaseMessagesRef.current.set(testingActivePhase, [...messages])
                    
                    // 切换活跃阶段
                    setTestingActivePhase(phase.id as PhaseId)
                    setTestingViewingPhase(phase.id)
                    setCurrentTool(null)
                    
                    // 尝试从缓存加载目标阶段的消息
                    const cachedMessages = phaseMessagesRef.current.get(phase.id as PhaseId)
                    console.log('[Testing] 切换阶段:', phase.id, '缓存消息数:', cachedMessages?.length || 0)
                    if (cachedMessages && cachedMessages.length > 0) {
                      setMessages(cachedMessages)
                    } else if (testingSessionId) {
                      // 缓存为空时，从服务器加载历史
                      setMessages([])
                      try {
                        const phaseThreadId = `${testingSessionId}_${phase.id}`
                        const rawMessages = await fetchConversationHistory(phaseThreadId)
                        if (rawMessages.length > 0) {
                          const result = convertRawMessagesToDisplay(rawMessages, phaseThreadId)
                          setMessages(result.messages)
                          phaseMessagesRef.current.set(phase.id as PhaseId, result.messages)
                        }
                      } catch (e) {
                        console.log('该阶段暂无历史消息')
                      }
                    } else {
                      setMessages([])
                    }
                  }}
                  title={`切换到${phase.name}`}
                >
                  {isCompleted && <CheckCircleOutlined className="phase-tab-icon" style={{ color: '#52c41a' }} />}
                  {isCurrent && isTestingRunning && <LoadingOutlined spin className="phase-tab-icon" />}
                  <span className="phase-tab-name">{phase.name}</span>
                </div>
              )
            })}
          </div>
          
          {/* 当前查看阶段的任务列表 */}
          <div className="testing-panel-content">
            {testingTasks.length === 0 ? (
              <div className="testing-empty-state">
                {isTestingRunning && testingViewingPhase === testingCurrentPhase 
                  ? '等待任务创建...' 
                  : testingViewingPhase !== testingCurrentPhase
                    ? '该阶段暂无任务记录'
                    : '选择需求后发送消息开始'}
              </div>
            ) : (
              testingTasks.map((task, index) => (
                <div 
                  key={task.id} 
                  className={`testing-task-card ${task.status === 'in_progress' ? 'active' : ''} ${task.status === 'completed' ? 'completed' : ''}`}
                >
                  <div className="testing-task-title">
                    <span className="task-icon">
                      {task.status === 'completed' ? (
                        <CheckCircleOutlined style={{ color: '#52c41a' }} />
                      ) : task.status === 'in_progress' ? (
                        <LoadingOutlined spin />
                      ) : '○'}
                    </span>
                    <span>{index + 1}. {task.title}</span>
                  </div>
                  {task.status === 'in_progress' && task.progress > 0 && (
                    <div className="testing-task-progress">
                      <div className="testing-task-progress-bar">
                        <div className="testing-task-progress-fill" style={{ width: `${task.progress}%` }} />
                      </div>
                    </div>
                  )}
                  {task.status === 'completed' && task.result && (
                    <div className="testing-task-result">{task.result}</div>
                  )}
                </div>
              ))
            )}
          </div>
          
          <div className="testing-panel-footer">
            <div className="testing-progress-summary">
              <span className="label">{testingViewingPhaseInfo?.name || '进度'}: </span>
              <span className="value">{testingTasks.filter(t => t.status === 'completed').length}/{testingTasks.length} 完成</span>
            </div>
            <div style={{ height: 6, background: '#f0f0f0', borderRadius: 3 }}>
              <div style={{ 
                height: '100%', 
                width: `${testingTasks.length > 0 ? Math.round(testingTasks.filter(t => t.status === 'completed').length / testingTasks.length * 100) : 0}%`, 
                background: '#1890ff', 
                borderRadius: 3, 
                transition: 'width 0.3s' 
              }} />
            </div>
            {/* 查看阶段总结按钮 - 当阶段完成时显示 */}
            {testingViewingPhaseInfo?.status === 'completed' && testingSessionId && (
              <button 
                className="testing-summary-btn"
                disabled={summaryLoading}
                onClick={async () => {
                  try {
                    setSummaryLoading(true)
                    const results = await getTestingResults(testingSessionId!)
                    // 根据当前查看的阶段获取对应摘要
                    const summaryMap: Record<PhaseId, keyof TestingResults> = {
                      analysis: 'requirement_summary',
                      plan: 'test_plan',
                      generate: 'test_cases',
                    }
                    const summaryKey = summaryMap[testingViewingPhase]
                    const content = results[summaryKey]
                    if (content) {
                      setSummaryContent(JSON.stringify(content, null, 2))
                      setSummaryModalVisible(true)
                    } else {
                      showWarning('暂无该阶段的总结数据')
                    }
                  } catch (error) {
                    console.error('获取阶段总结失败:', error)
                    showWarning('获取阶段总结失败')
                  } finally {
                    setSummaryLoading(false)
                  }
                }}
              >
                {summaryLoading ? <LoadingOutlined /> : <FileTextOutlined />} 查看阶段总结
              </button>
            )}
          </div>
        </div>
      )}
      
      {/* 阶段总结弹窗 */}
      <Modal
        title={`${testingViewingPhaseInfo?.name || '阶段'}总结`}
        open={summaryModalVisible}
        onCancel={() => setSummaryModalVisible(false)}
        footer={null}
        width={700}
        styles={{ body: { maxHeight: '60vh', overflowY: 'auto' } }}
      >
        {summaryContent && (
          <MarkdownPreview
            source={'```json\n' + summaryContent + '\n```'}
            style={{ background: 'transparent', fontSize: 14 }}
            wrapperElement={{ "data-color-mode": "light" }}
          />
        )}
      </Modal>

      <div className={`chat-main ${messages.length === 0 ? 'empty-chat' : ''} ${currentAgentType === 'intelligent_testing' ? 'with-task-panel' : ''}`}>
        {/* Agent 选择器 - 对话区域左上角 */}
        {agentTypes.length > 0 && (
          <div className="agent-selector-header">
            <div className="agent-dropdown-wrapper">
              {/* 有对话内容时显示锁定状态 */}
              {hasConversationContent ? (
                <div className="agent-locked-info">
                  <LockOutlined className="locked-icon" />
                  <span className="locked-value">
                    {agentTypes.find(a => a.agent_type === currentAgentType)?.name || 'Agent'}
                  </span>
                </div>
              ) : (
                <>
                  <button 
                    className="agent-dropdown-trigger"
                    onClick={() => setIsAgentDropdownOpen(!isAgentDropdownOpen)}
                  >
                    <span className="agent-trigger-name">
                      {agentTypes.find(a => a.agent_type === currentAgentType)?.name || 'Agent'}
                    </span>
                    <DownOutlined className={`agent-trigger-arrow ${isAgentDropdownOpen ? 'open' : ''}`} />
                  </button>
                  
                  {isAgentDropdownOpen && (
                    <div className="agent-dropdown-menu">
                      {agentTypes.map(agent => {
                        const isSelected = currentAgentType === agent.agent_type
                        return (
                          <div
                            key={agent.agent_type}
                            className={`agent-dropdown-item ${isSelected ? 'selected' : ''}`}
                            onClick={() => {
                              setCurrentAgentType(agent.agent_type)
                              setIsAgentDropdownOpen(false)
                            }}
                          >
                            <div className="agent-item-content">
                              <span className="agent-item-name">{agent.name}</span>
                              <span className="agent-item-desc">{agent.description}</span>
                            </div>
                            {isSelected && <CheckCircleOutlined className="agent-item-check" />}
                          </div>
                        )
                      })}
                    </div>
                  )}
                </>
              )}
            </div>
            
            {/* 日志排查配置选择器 - 仅 log_troubleshoot Agent 显示 */}
            {currentAgentType === 'log_troubleshoot' && businessLines.length > 0 && (
              <div className="log-query-selectors">
                {/* 有对话内容时显示锁定状态 */}
                {hasConversationContent ? (
                  <div className="log-locked-info">
                    <LockOutlined className="locked-icon" />
                    <span className="locked-value">{businessLine}</span>
                    {businessLine === '私有化' && privateServer && (
                      <>
                        <span className="locked-separator">·</span>
                        <span className="locked-value">{privateServer}</span>
                      </>
                    )}
                  </div>
                ) : (
                  <>
                    {/* 业务线选择器 */}
                    <div className="log-dropdown-wrapper">
                      <button
                        className="log-dropdown-trigger"
                        onClick={() => {
                          setIsBusinessLineOpen(!isBusinessLineOpen)
                          setIsPrivateServerOpen(false)
                        }}
                      >
                        <span className="log-trigger-name">{businessLine || '选择业务线'}</span>
                        <DownOutlined className={`log-trigger-arrow ${isBusinessLineOpen ? 'open' : ''}`} />
                      </button>
                      {isBusinessLineOpen && (
                        <div className="log-dropdown-menu">
                          {businessLines.map(opt => (
                            <div
                              key={opt.value}
                              className={`log-dropdown-item ${businessLine === opt.value ? 'selected' : ''}`}
                              onClick={() => handleBusinessLineChange(opt.value)}
                            >
                              <span>{opt.label}</span>
                              {businessLine === opt.value && <CheckCircleOutlined className="log-item-check" />}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                    
                    {/* 私有化集团选择器 - 仅私有化业务线显示 */}
                    {businessLine === '私有化' && privateServers.length > 0 && (
                      <div className="log-dropdown-wrapper">
                        <button
                          className="log-dropdown-trigger"
                          onClick={() => {
                            setIsPrivateServerOpen(!isPrivateServerOpen)
                            setIsBusinessLineOpen(false)
                          }}
                        >
                          <span className="log-trigger-name">{privateServer || '选择集团'}</span>
                          <DownOutlined className={`log-trigger-arrow ${isPrivateServerOpen ? 'open' : ''}`} />
                        </button>
                        {isPrivateServerOpen && (
                          <div className="log-dropdown-menu">
                            {privateServers.map(opt => (
                              <div
                                key={opt.value}
                                className={`log-dropdown-item ${privateServer === opt.value ? 'selected' : ''}`}
                                onClick={() => handlePrivateServerChange(opt.value)}
                              >
                                <span>{opt.label}</span>
                                {privateServer === opt.value && <CheckCircleOutlined className="log-item-check" />}
                              </div>
                            ))}
                          </div>
                        )}
                      </div>
                    )}
                  </>
                )}
              </div>
            )}
            
            {/* 智能测试配置选择器 - 仅 intelligent_testing Agent 显示 */}
            {currentAgentType === 'intelligent_testing' && (
              <div className="log-query-selectors">
                {/* 有 sessionId 时显示锁定的需求信息 */}
                {testingSessionId && testingSessionStatus ? (
                  <div className="testing-locked-info">
                    <LockOutlined className="locked-icon" />
                    <span className="locked-value">
                      {testingSessionStatus.requirement_name || `#${testingSessionStatus.requirement_id}`}
                    </span>
                    <span className="locked-badge">已锁定</span>
                  </div>
                ) : (
                  <>
                {/* 迭代选择器 */}
                <div className="testing-dropdown-wrapper log-dropdown-wrapper">
                  <button
                    className="log-dropdown-trigger"
                    onClick={() => {
                      setIsIterationOpen(!isIterationOpen)
                      setIsIssueOpen(false)
                    }}
                  >
                    <span className="log-trigger-name">
                      {selectedIteration ? selectedIteration.name : (isIterationLoading ? '加载中...' : '选择迭代')}
                    </span>
                    <DownOutlined className={`log-trigger-arrow ${isIterationOpen ? 'open' : ''}`} />
                  </button>
                  {isIterationOpen && (
                    <div className="log-dropdown-menu" style={{ maxHeight: '300px', overflowY: 'auto', overflowX: 'hidden' }}>
                      {/* 搜索框 + 搜索按钮 */}
                      <div style={{ padding: '8px', borderBottom: '1px solid #f0f0f0', display: 'flex', gap: '6px' }}>
                        <input
                          type="text"
                          placeholder="输入关键词搜索..."
                          value={iterationSearchText}
                          onChange={(e) => setIterationSearchText(e.target.value)}
                          onKeyDown={(e) => { if (e.key === 'Enter') handleSearchIterations() }}
                          onClick={(e) => e.stopPropagation()}
                          style={{
                            flex: 1,
                            padding: '6px 10px',
                            border: '1px solid #d9d9d9',
                            borderRadius: '6px',
                            fontSize: '13px',
                            outline: 'none',
                          }}
                        />
                        <button
                          onClick={(e) => { e.stopPropagation(); handleSearchIterations() }}
                          disabled={isIterationLoading}
                          style={{
                            padding: '6px 12px',
                            border: '1px solid #1890ff',
                            borderRadius: '6px',
                            background: '#1890ff',
                            color: '#fff',
                            cursor: isIterationLoading ? 'not-allowed' : 'pointer',
                            fontSize: '13px',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '4px',
                          }}
                        >
                          <SearchOutlined />
                        </button>
                      </div>
                      {isIterationLoading && (
                        <div style={{ padding: '12px', color: '#999', textAlign: 'center' }}>搜索中...</div>
                      )}
                      {!isIterationLoading && iterations.map(iteration => (
                          <div
                            key={iteration.code}
                            className={`log-dropdown-item ${selectedIteration?.code === iteration.code ? 'selected' : ''}`}
                            onClick={() => {
                              setSelectedIteration(iteration)
                              setIsIterationOpen(false)
                              setIterationSearchText('')
                            }}
                          >
                            <span>{iteration.name}</span>
                            {selectedIteration?.code === iteration.code && <CheckCircleOutlined className="log-item-check" />}
                          </div>
                        ))}
                      {!isIterationLoading && iterations.length === 0 && (
                        <div style={{ padding: '12px', color: '#999', textAlign: 'center' }}>暂无匹配迭代</div>
                      )}
                    </div>
                  )}
                </div>
                
                {/* 需求选择器 - 仅选择迭代后显示 */}
                {selectedIteration && (
                  <div className="testing-dropdown-wrapper log-dropdown-wrapper">
                    <button
                      className="log-dropdown-trigger"
                      onClick={() => {
                        setIsIssueOpen(!isIssueOpen)
                        setIsIterationOpen(false)
                      }}
                    >
                      <span className="log-trigger-name">
                        {selectedIssue ? `#${selectedIssue.code} ${selectedIssue.name}`.slice(0, 30) + (selectedIssue.name.length > 20 ? '...' : '') : (isIssueLoading ? '加载中...' : '选择需求')}
                      </span>
                      <DownOutlined className={`log-trigger-arrow ${isIssueOpen ? 'open' : ''}`} />
                    </button>
                    {isIssueOpen && (
                      <div className="log-dropdown-menu" style={{ maxHeight: '300px', overflow: 'auto', minWidth: '350px' }}>
                        {/* 搜索框 + 搜索按钮 */}
                        <div style={{ padding: '8px', borderBottom: '1px solid #f0f0f0', display: 'flex', gap: '6px' }}>
                          <input
                            type="text"
                            placeholder="输入关键词搜索..."
                            value={issueSearchText}
                            onChange={(e) => setIssueSearchText(e.target.value)}
                            onKeyDown={(e) => { if (e.key === 'Enter') handleSearchIssues() }}
                            onClick={(e) => e.stopPropagation()}
                            style={{
                              flex: 1,
                              padding: '6px 10px',
                              border: '1px solid #d9d9d9',
                              borderRadius: '6px',
                              fontSize: '13px',
                              outline: 'none',
                            }}
                          />
                          <button
                            onClick={(e) => { e.stopPropagation(); handleSearchIssues() }}
                            disabled={isIssueLoading}
                            style={{
                              padding: '6px 12px',
                              border: '1px solid #1890ff',
                              borderRadius: '6px',
                              background: '#1890ff',
                              color: '#fff',
                              cursor: isIssueLoading ? 'not-allowed' : 'pointer',
                              fontSize: '13px',
                              display: 'flex',
                              alignItems: 'center',
                              gap: '4px',
                            }}
                          >
                            <SearchOutlined />
                          </button>
                        </div>
                        {isIssueLoading && (
                          <div style={{ padding: '12px', color: '#999', textAlign: 'center' }}>搜索中...</div>
                        )}
                        {!isIssueLoading && issues.map(issue => (
                            <div
                              key={issue.code}
                              className={`log-dropdown-item ${selectedIssue?.code === issue.code ? 'selected' : ''}`}
                              onClick={() => {
                                setSelectedIssue(issue)
                                setIsIssueOpen(false)
                                setIssueSearchText('')
                              }}
                              style={{ flexDirection: 'column', alignItems: 'flex-start' }}
                            >
                              <span style={{ fontWeight: 500 }}>#{issue.code} {issue.name}</span>
                              <span style={{ fontSize: '12px', color: '#999', marginTop: '2px' }}>
                                {issue.status_name} · {issue.assignee_names.join(', ') || '未指派'}
                              </span>
                              {selectedIssue?.code === issue.code && (
                                <CheckCircleOutlined className="log-item-check" style={{ position: 'absolute', right: '12px', top: '50%', transform: 'translateY(-50%)' }} />
                              )}
                            </div>
                          ))}
                        {!isIssueLoading && issues.length === 0 && (
                          <div style={{ padding: '12px', color: '#999', textAlign: 'center' }}>暂无匹配需求</div>
                        )}
                      </div>
                    )}
                  </div>
                )}
                </>
                )}
              </div>
            )}
          </div>
        )}
        
        <div className="chat-message-list" ref={messageListRef} onScroll={handleScroll}>
          <div className="chat-content-width">
            {isHistoryLoading ? (
              <div className="history-loading-container">
                <LoadingOutlined spin style={{ fontSize: 32, color: '#1890ff' }} />
                <span className="history-loading-text">正在加载对话...</span>
              </div>
            ) : messages.length === 0 ? (
              <WelcomeScreen 
                key={`${currentAgentType}-${businessLine || ''}-${privateServer || ''}-${testingActivePhase}`}
                onSuggestionClick={(q) => sendMessage(q)} 
                agentType={currentAgentType}
                businessLine={businessLine}
                privateServer={privateServer}
              />
            ) : (
              <>
                {messages.map((msg, idx) => {
                  // 阶段分隔符消息 - 特殊渲染
                  if (msg.role === 'phase_divider') {
                    return (
                      <div key={msg.id} className="phase-divider">
                        <div className="phase-divider-line" />
                        <div className="phase-divider-badge">
                          <span className="phase-divider-icon">🚀</span>
                          <span className="phase-divider-text">
                            阶段 {msg.phaseIndex}: {msg.phaseName}
                          </span>
                        </div>
                        <div className="phase-divider-line" />
                      </div>
                    )
                  }
                  
                  // 计算该 assistant 消息对应的用户消息索引
                  let userMsgIndex = -1
                  if (msg.role === 'assistant') {
                    let count = 0
                    for (let i = 0; i < idx; i++) {
                      if (messages[i].role === 'user') {
                        userMsgIndex = count
                        count++
                      }
                    }
                  }
                  
                  // 判断是否可以重新生成（非正在生成的消息）
                  const isCurrentlyGenerating = msg.role === 'assistant' && 
                    idx === messages.length - 1 && isLoading
                  const canRegenerate = msg.role === 'assistant' && !isCurrentlyGenerating
                  
                  return (
                    <MessageItem 
                      key={msg.id} 
                      message={msg}
                      isLoading={isLoading}
                      canRegenerate={canRegenerate}
                      onRegenerate={() => userMsgIndex >= 0 && handleRegenerate(userMsgIndex)}
                      onRollback={() => handleRollback(msg.id)}
                      toolSummaries={toolSummaries}
                      activeTools={activeTools}
                      activeToolsRef={activeToolsRef}
                    />
                  )
                })}
                {/* 测试助手：阶段完成后显示进入下一阶段按钮 */}
                {currentAgentType === 'intelligent_testing' && 
                 testingSessionId && 
                 testingActivePhase !== 'generate' && 
                 testingSessionStatus?.phases?.[testingActivePhase]?.has_summary && 
                 !isLoading && (
                  <div className="next-phase-message">
                    <div className="next-phase-content">
                      <CheckCircleOutlined className="next-phase-icon" />
                      <span className="next-phase-text">
                        {testingActivePhase === 'analysis' ? '需求分析' : '测试方案'}阶段已完成
                      </span>
                      <button
                        className="next-phase-btn"
                        onClick={() => {
                          const nextPhase = testingActivePhase === 'analysis' ? 'plan' : 'generate'
                          phaseMessagesRef.current.set(testingActivePhase, [...messages])
                          refreshTestingSessionStatus()
                          setTestingActivePhase(nextPhase as PhaseId)
                          setTestingViewingPhase(nextPhase as PhaseId)
                          setTestingCurrentPhase(nextPhase as PhaseId)
                          setMessages([])
                          setCurrentTool(null)
                        }}
                      >
                        进入下一阶段: {testingActivePhase === 'analysis' ? '测试方案' : '用例生成'} →
                      </button>
                    </div>
                  </div>
                )}
                {/* 占位符，用于滚动 */}
                <div ref={messagesEndRef} style={{ height: 1 }} />
              </>
            )}
          </div>
        </div>

        <div className="input-area-wrapper">
          <div className="input-container" style={{ flexDirection: 'column', alignItems: 'stretch' }}>
            {/* 文件预览区域 - 在输入框内部上方 */}
            {(uploadedFiles.length > 0 || pendingFiles.length > 0) && (
              <div style={{ 
                display: 'flex', 
                flexWrap: 'wrap', 
                gap: '6px',
                padding: '8px 8px 6px 8px',  /* 左右都和按钮对齐 */
              }}>
                {/* 上传中的文件 */}
                {pendingFiles.map(file => (
                  <div 
                    key={file.id}
                    title={file.file.name}
                    className="file-thumbnail-wrapper"
                    style={{ 
                      position: 'relative',
                      width: '48px',
                      height: '48px',
                      marginRight: '8px',
                      marginTop: '8px',
                    }}
                  >
                    <div style={{
                      width: '100%',
                      height: '100%',
                      borderRadius: '8px',
                      border: '1px solid #e0e0e0',
                      background: '#f5f5f5',
                      overflow: 'hidden',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      cursor: 'pointer',
                    }}>
                      {file.previewUrl ? (
                        <img 
                          src={file.previewUrl} 
                          alt={file.file.name}
                          style={{ 
                            width: '100%', 
                            height: '100%', 
                            objectFit: 'cover',
                            opacity: file.status === 'uploading' ? 0.7 : 1,
                          }} 
                        />
                      ) : (
                        <FileOutlined style={{ fontSize: 18, color: '#999' }} />
                      )}
                      {/* 上传进度 - 白色圆环 loading 动画 */}
                      {file.status === 'uploading' && (
                        <div style={{
                          position: 'absolute',
                          top: 0,
                          left: 0,
                          right: 0,
                          bottom: 0,
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          background: 'rgba(0,0,0,0.3)',
                          borderRadius: '8px',
                        }}>
                          <div className="upload-spinner" />
                        </div>
                      )}
                      {/* 错误状态 */}
                      {file.status === 'error' && (
                        <div style={{
                          position: 'absolute',
                          top: 0,
                          left: 0,
                          right: 0,
                          bottom: 0,
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          background: 'rgba(255,77,79,0.15)',
                          borderRadius: '8px',
                        }}>
                          <CloseCircleOutlined style={{ fontSize: 14, color: '#ff4d4f' }} />
                        </div>
                      )}
                    </div>
                    {/* 删除按钮 - 在边线上，hover 时显示 */}
                    <div
                      className="file-thumbnail-close"
                      onClick={(e) => { e.stopPropagation(); removePendingFile(file.id) }}
                    >
                      <CloseOutlined style={{ fontSize: 10, color: '#666' }} />
                    </div>
                  </div>
                ))}
                
                {/* 已上传的文件 - 图片用缩略图，文档用卡片 */}
                {uploadedFiles.map(file => (
                  file.type === 'image' ? (
                    <div 
                      key={file.id}
                      title={file.filename}
                      className="file-thumbnail-wrapper"
                      style={{ 
                        position: 'relative',
                        width: '48px',
                        height: '48px',
                        marginRight: '8px',
                        marginTop: '8px',
                      }}
                    >
                      <div style={{
                        width: '100%',
                        height: '100%',
                        borderRadius: '8px',
                        border: '1px solid #e0e0e0',
                        background: '#f5f5f5',
                        overflow: 'hidden',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                      }}>
                        <Image
                          src={file.url}
                          width={48}
                          height={48}
                          style={{ objectFit: 'cover', cursor: 'pointer' }}
                          preview={{ mask: null }}
                        />
                      </div>
                      <div
                        className="file-thumbnail-close"
                        onClick={(e) => { e.stopPropagation(); removeFile(file.id) }}
                      >
                        <CloseOutlined style={{ fontSize: 10, color: '#666' }} />
                      </div>
                    </div>
                  ) : (
                    <FileAttachmentCard 
                      key={file.id}
                      attachment={{
                        file_id: file.id,
                        url: file.url,
                        type: file.type as 'document',
                        filename: file.filename,
                        content_type: file.contentType,
                        size: file.size,
                      }}
                      pending
                      onRemove={() => removeFile(file.id)}
                    />
                  )
                ))}
              </div>
            )}
            
            {/* 输入行 */}
            <div style={{ display: 'flex', alignItems: 'center', width: '100%' }}>
            {/* 左侧文件工具按钮 */}
            <div className="file-tools-wrapper">
              <button
                className="file-tools-btn"
                onClick={() => setIsFileToolsOpen(!isFileToolsOpen)}
                disabled={isLoading}
                title="添加内容"
              >
                <PlusOutlined style={{ fontSize: 18 }} />
              </button>
              
              {/* 文件工具弹窗 */}
              {isFileToolsOpen && (
                <div className="file-tools-menu">
                  <Upload
                    customRequest={({ file }) => {
                      handleUpload(file as File)
                      setIsFileToolsOpen(false)
                    }}
                    showUploadList={false}
                    accept="image/*,.pdf,.txt,.md,.log,.json,.py,.js,.ts,.java,.cpp,.c,.go"
                    disabled={isLoading || uploading}
                  >
                    <div className="file-tools-item">
                      <PaperClipOutlined className="file-tools-item-icon" />
                      <div className="file-tools-item-content">
                        <span className="file-tools-item-name">上传附件</span>
                        <span className="file-tools-item-desc">支持图片、文档、代码文件等</span>
                      </div>
                    </div>
                  </Upload>
                  
                  {/* 后续可扩展更多功能 */}
                  {/* <div className="file-tools-item" onClick={() => { ... }}>
                    <FileTextOutlined className="file-tools-item-icon" />
                    <div className="file-tools-item-content">
                      <span className="file-tools-item-name">新建文档</span>
                      <span className="file-tools-item-desc">创建临时文档</span>
                    </div>
                  </div> */}
                </div>
              )}
            </div>
            
            {/* 智能测试助手：空状态时显示预设指令 */}
            {(() => {
              const isTestingEmpty = currentAgentType === 'intelligent_testing' && messages.length === 0
              const testingPresetText: Record<string, string> = {
                analysis: '点击发送按钮开始分析需求',
                plan: '开始生成测试方案',
                generate: '开始生成测试用例',
              }
              const presetValue = isTestingEmpty ? testingPresetText[testingActivePhase] || '' : ''
              
              return (
                <textarea
                  ref={inputRef}
                  className={`chat-textarea ${isTestingEmpty ? 'testing-preset' : ''}`}
                  placeholder="输入问题，开始探索（支持拖拽/粘贴图片）"
                  value={isTestingEmpty ? presetValue : inputValue}
                  onChange={e => !isTestingEmpty && setInputValue(e.target.value)}
                  readOnly={isTestingEmpty}
                  onKeyDown={e => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                      e.preventDefault()
                      if (!isLoading) {
                        isTestingEmpty ? sendMessage(presetValue) : sendMessage()
                      }
                    }
                  }}
                  rows={1}
                />
              )
            })()}
            
            <div className="action-buttons">
              {isLoading ? (
                <button className="stop-btn" onClick={handleStop} aria-label="停止生成" />
              ) : (
                <button 
                  className="send-btn" 
                  onClick={() => {
                    const isTestingEmpty = currentAgentType === 'intelligent_testing' && messages.length === 0
                    const testingPresetText: Record<string, string> = {
                      analysis: '点击发送按钮开始分析需求',
                      plan: '开始生成测试方案',
                      generate: '开始生成测试用例',
                    }
                    isTestingEmpty ? sendMessage(testingPresetText[testingActivePhase]) : sendMessage()
                  }}
                  disabled={
                    currentAgentType === 'intelligent_testing' && messages.length === 0
                      ? false  // 测试助手空状态时始终可点击
                      : !inputValue.trim() && uploadedFiles.length === 0
                  }
                >
                  <ArrowUpOutlined style={{ fontSize: 20, fontWeight: 'bold' }} />
                </button>
              )}
            </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

export default ChatPage
