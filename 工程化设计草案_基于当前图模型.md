# 工程化设计文档（基于当前图模型）

> 本文档严格以当前 `test/neo4j_load_open_card.py` 中的图模型为基准，不擅自增加新的节点类型或字段，仅在此基础上讨论工程化落地方案。

---

## 1. 目标与范围

### 1.1 目标

围绕当前 Neo4j 图模型中已有的四类节点与关系：

- 节点标签：
  - `Business`  （属性：`process_id`, `name`, `channel`, `description`, `entrypoints`）
  - `Step`      （属性：`step_id`, `name`, `description`, `step_type`）
  - `Implementation`（属性：`impl_id`, `name`, `type`, `system`, `description`, `code_ref`）
  - `DataResource`  （属性：`resource_id`, `name`, `type`, `system`, `description`）
- 关系：
  - `(:Business)-[:START_AT]->(:Step)`
  - `(:Step)-[:NEXT {process_id}]->(:Step)`
  - `(:Step)-[:EXECUTED_BY]->(:Implementation)`
  - `(:Implementation)-[:ACCESSES_RESOURCE {access_type, access_pattern}]->(:DataResource)`

在**不扩展图节点/关系字段的前提下**，完成一份工程化方案草案，目标包括：

- 支持多条业务流程的配置与管理（不只 `c_open_card`）。
- 以关系型数据库（如 MySQL）为**主数据源**，围绕 `Business` / `Step` / `Implementation` / `DataResource` 四类节点和它们之间的关系建模。
- 通过同步服务将主数据投影为 Neo4j 图视图，维持与现有节点/关系模型完全一致。
- 后端整体定位为**查询引擎（API 优先）**：对外通过 HTTP 接口提供业务流程与数据资源的查询与问答能力。
- 搭建一个内部使用的管理前端（Admin Console）和 QA 控制台，用于配置流程、数据资源以及调试问答效果，演示从“配置 → 图谱 → LLM”的闭环。

### 1.2 一期范围（MVP）

- 范围内：
  - 多个 `Business` 流程及其 `Step` 顺序（只考虑线性主链路 + 简单分支占位）。
  - 每个 `Step` 与一个或多个 `Implementation` 的绑定。
  - `Implementation` 与 `DataResource` 的访问关系（读/写模式描述）。
  - 一个简单的 Web/CLI 问答接口，调用 LLM 基于 `Business` 子图回答“这条流程怎么走、涉及哪些系统和资源”。
  - 在线“流程骨架生成”：基于采集到的原始数据（如 curl、日志、trace）和简要业务描述，调用 AI 生成候选流程骨架，在前端 `/admin/skeleton` 页面中预览与精修，最终落盘为 7 张表结构。
- 范围外（后续迭代）：
  - 更复杂的错误模式、版本灰度、权限模型等。

---

## 2. 当前图模型回顾

本小节仅做事实性描述，严格对应 `neo4j_load_open_card.py` 中的写入逻辑。

### 2.1 SAMPLE_DATA 结构

当前脚本中的配置来源为 `SAMPLE_DATA: Dict[str, List[Dict[str, Any]]]`，包含：

- `"business_processes"`：业务流程列表
  - 字段：`process_id`, `name`, `channel`, `domain`, `description`, `entrypoints`
- `"business_process_steps"`：流程内步骤
  - 字段：`step_id`, `process_id`, `order_no`, `capability_id`, `name`, `branch`, `role`, `condition`, `is_optional?`
- `"business_capabilities"`：业务能力
  - 字段：`capability_id`, `domain`, `name`, `description`, `capability_type`
- `"data_resources"`：数据资源
  - 字段：`name`, `resource_id`, `type`, `system`, `location`, `entity_id`, `description`
- `"capability_implementations"`：能力的系统实现
  - 字段：`capability_id`, `system`, `entry_type`, `entry_name`, `code_ref`
- `"capability_data_access"`：能力对数据资源的访问
  - 字段：`capability_id`, `resource_id`, `access_type`, `access_pattern`

> 说明：`domain`, `location`, `entity_id` 等字段存在于 SAMPLE_DATA 中，但在当前图模型中**没有写入节点/关系属性**，仅作为配置来源。

### 2.2 写入 Neo4j 的节点与属性

根据 `load_*` 函数，实际写入 Neo4j 的结构为：

- `(:Business {process_id, name, channel, description, entrypoints})`
  - 唯一约束：`Business(process_id)`
- `(:Step {step_id, name, description, step_type})`
  - `step_id` = `capability_id`（来自 `business_capabilities`）
  - 唯一约束：`Step(step_id)`
- `(:Implementation {impl_id, name, type, system, description, code_ref})`
  - `impl_id` 为脚本内部生成（如 `impl_1`, `impl_2` ...）
  - 唯一约束：`Implementation(impl_id)`
- `(:DataResource {resource_id, name, type, system, description})`
  - `resource_id` 为如 `member_db.user_card`
  - 唯一约束：`DataResource(resource_id)`

### 2.3 写入 Neo4j 的关系与属性

- 流程起点：
  - `(:Business {process_id})-[:START_AT]->(:Step {step_id})`
- 步骤顺序（主链）：
  - `(:Step {step_id=from})-[:NEXT {process_id}]->(:Step {step_id=to})`
- 步骤与实现：
  - `(:Step {step_id=capability_id})-[:EXECUTED_BY]->(:Implementation {impl_id})`
- 实现与数据资源：
  - `(:Implementation {impl_id})-[:ACCESSES_RESOURCE {access_type, access_pattern}]->(:DataResource {resource_id})`

> 关键设计：当前版本中，**不再单独建 BusinessCapability 节点**，而是用 `capability_id` 作为 `Step.step_id`，并通过 `EXECUTED_BY` + `ACCESSES_RESOURCE` 间接承载“能力”的技术视图。

---

## 3. 工程化总体方案（保持图模型不变）

### 3.1 组件划分

在保持 Neo4j 中节点/关系/属性不变的前提下，引入以下组件：

- **配置存储层（MySQL 等）**
  - 以当前图模型为核心，围绕 `Business` / `Step` / `Implementation` / `DataResource` 四类节点与它们之间的关系设计 4 + 3 张表（见第 4 章）。
  - 作为节点属性和关系配置的主数据源，不再保留 `business_capability` 等中间概念表。
- **图谱同步服务（Graph Sync Service）**
  - 从 MySQL 读取配置，生成与当前脚本完全相同的 Neo4j 图结构。
  - 保证图谱与主数据在字段和含义上严格一致。
- **图谱访问 API（Graph API Service）**
  - 封装常用查询：按 `process_id` 获取完整子图、列出流程、按 `resource_id` 反查流程等。
  - 面向外部系统暴露为“查询引擎”的核心接口。
- **管理前端（Admin UI）**
  - 对 `Business`/`Step`/`Implementation`/`DataResource` 及它们之间的关系进行可视化查看和编辑。
  - 提供简化版“流程画布”，但画布数据最终仍落盘为与图模型字段对齐的结构。
- **问答与编排服务（AI Orchestrator & QA Console）**
  - 基于 Graph API，从 Neo4j 取出 `Business` 子图，整理成 JSON 上下文，调用 LLM 生成业务描述性回答。
  - 对外以 HTTP API 形态提供问答能力；前端 QA 页面仅作为内部调试和验收入口。
  - 同时对接骨架生成服务，为采集到的原始数据生成候选流程骨架。

- **数据采集与骨架生成服务（Skeleton / Flow Mining Service）**
  - 提供面向内部使用的 HTTP 接口，将“原始数据 + 业务描述”转换为流程骨架草案。
  - 严格遵循“不持久化原始数据”的约束，仅在内存中处理原始数据，请求结束后即丢弃。
  - 只在用户确认后，将结构化骨架数据写入 `business` / `step` / `business_step` 等表，并可选触发图谱同步。

### 3.2 数据流概览

1. 管理前端/配置脚本 → 写入/更新 MySQL 表（按照第 4 章定义的 7 张表结构）。
2. 图谱同步服务监听配置变更或被手动触发，执行：
   - 按 `process_id` 从 MySQL 拉取完整配置；
   - 在 Neo4j 中清理该 `process_id` 对应子图（可选策略）；
   - 以当前 `neo4j_load_open_card.py` 的逻辑为模板，重建 `Business`/`Step`/`Implementation`/`DataResource` 节点和关系。
3. AI 问答服务通过 Graph API 查询：
   - `Business(process_id)` 及其 `START_AT` + `NEXT` 路径上的 `Step`；
   - 每个 `Step` 的 `EXECUTED_BY` 实现和 `ACCESSES_RESOURCE` 关系；
   - 生成结构化上下文并调用 LLM。

---

## 4. 关系型数据库映射设计（严格对齐当前图模型）

本节的表结构围绕图中的四类节点与三类关系设计为 7 张表：

- 节点表：`business` / `step` / `implementation` / `data_resource`
- 关系表：`business_step` / `step_implementation` / `implementation_dataresource`

只保留当前图写入和同步逻辑实际需要的字段，不额外增加业务字段，仅适当补充技术性主键/时间戳字段（如 `id`, `created_at`, `updated_at`），且这些技术字段不会映射到 Neo4j。

### 4.1 节点表（Business / Step / Implementation / DataResource）

- **`business`**（对应 `(:Business)` 节点）

  - `id` (PK，自增，用于内部管理，不映射到图)
  - `process_id` (string, unique)  —— 对应 Business.process_id
  - `name` (string)                —— 对应 Business.name
  - `channel` (string)             —— 对应 Business.channel
  - `description` (string)         —— 对应 Business.description
  - `entrypoints` (json/text)      —— 对应 Business.entrypoints
  - `created_at`, `updated_at`     —— 技术字段

- **`step`**（对应 `(:Step)` 节点）

  - `id` (PK，自增，用于内部管理，不映射到图)
  - `step_id` (string, unique)     —— 对应 Step.step_id（原 SAMPLE_DATA 中的 capability_id）
  - `name` (string)                —— 对应 Step.name
  - `description` (string)         —— 对应 Step.description
  - `step_type` (string)           —— 对应 Step.step_type
  - `created_at`, `updated_at`

- **`implementation`**（对应 `(:Implementation)` 节点）

  - `id` (PK，自增)
  - `impl_id` (string, unique)     —— 映射为 Implementation.impl_id（可由同步服务按规则生成）
  - `name` (string)                —— 对应 Implementation.name
  - `type` (string)                —— 对应 Implementation.type
  - `system` (string)              —— 对应 Implementation.system
  - `description` (string)         —— 对应 Implementation.description
  - `code_ref` (string)            —— 对应 Implementation.code_ref
  - `created_at`, `updated_at`

- **`data_resource`**（对应 `(:DataResource)` 节点）

  - `id` (PK，自增)
  - `resource_id` (string, unique)  —— 映射为 DataResource.resource_id
  - `name` (string)                 —— 映射为 DataResource.name
  - `type` (string)                 —— 映射为 DataResource.type
  - `system` (string)               —— 映射为 DataResource.system
  - `description` (string)          —— 映射为 DataResource.description
  - `created_at`, `updated_at`

> 在这个设计中，原先 SAMPLE_DATA 中的 `business_capabilities` 等中间表不再保留，能力的业务含义直接由 `step` 节点承载。

### 4.2 关系表（Business ↔ Step / Step ↔ Implementation / Implementation ↔ DataResource）

- **`business_step`**

  - 用于将多个 `step` 组装到某个 `business` 流程下，并表达步骤顺序。
  - 字段：
    - `id` (PK，自增)
    - `process_id` (string, FK → business.process_id)
    - `step_id` (string, FK → step.step_id)
    - `order_no` (int)            —— 在流程内的顺序号
    - `created_at`, `updated_at`

  - 图映射：
    - 同步服务按某个 `process_id` 查询所有 `business_step`，按 `order_no` 排序：
      - 首个步骤生成 `(:Business {process_id})-[:START_AT]->(:Step {step_id})`；
      - 相邻步骤对生成 `(:Step {from_step})-[:NEXT {process_id}]->(:Step {to_step})`。

- **`step_implementation`**

  - 表示某个 `step` 可以由哪些 `implementation` 执行，多对多关系。
  - 字段：
    - `id` (PK，自增)
    - `step_id` (string, FK → step.step_id)
    - `impl_id` (string, FK → implementation.impl_id)
    - `created_at`, `updated_at`

  - 图映射：
    - 每一行同步为一条 `(:Step {step_id})-[:EXECUTED_BY]->(:Implementation {impl_id})` 关系。

- **`implementation_dataresource`**

  - 表示某个 `implementation` 访问哪些 `data_resource`，以及访问方式。
  - 字段：
    - `id` (PK，自增)
    - `impl_id` (string, FK → implementation.impl_id)
    - `resource_id` (string, FK → data_resource.resource_id)
    - `access_type` (string)
    - `access_pattern` (string)
    - `created_at`, `updated_at`

  - 图映射：
    - 每一行同步为一条 `(:Implementation {impl_id})-[:ACCESSES_RESOURCE {access_type, access_pattern}]->(:DataResource {resource_id})` 关系。

### 4.3 与 SAMPLE_DATA 的兼容迁移

在从 PoC 迁移到上述 7 张表时，可以采用一次性转换脚本：

- `business_processes` → `business`；
- `business_process_steps` 中的 `capability_id` → `step.step_id`，并根据需要补充 `step.name` / `step.description` / `step_type`；
- `business_step` 从 `business_process_steps` 生成，只保留 `process_id` / `capability_id`（映射到 `step_id`）/ `order_no`；
- `capability_implementations` → `implementation` + `step_implementation`；
- `data_resources` → `data_resource`；
- `capability_data_access` → `implementation_dataresource`（按实现与资源的映射规则转换）。

---

## 5. 图谱同步服务设计

### 5.1 同步接口

提供一个按流程粒度的同步接口，例如：

- `sync_process(process_id: str) -> None`

行为：

1. 从 MySQL 中读取：
   - 该 `process_id` 的 `business` 记录；
   - 对应的 `business_step` 列表；
   - 所有相关的 `step` / `step_implementation` / `implementation` / `implementation_dataresource` / `data_resource`。
2. 在 Neo4j 中：
   - 可选：删除该 `process_id` 相关的 `Business` 节点及其关联子图（避免脏数据）。
   - 按当前 `neo4j_load_open_card.py` 逻辑依次执行：
     - 创建 `Business` 节点；
     - 创建 `Step` 节点，并根据 `order_no` 构建一条 `START_AT` + `NEXT` 链路；
     - 创建 `DataResource` 节点；
     - 创建 `Implementation` 节点；
     - 建立 `EXECUTED_BY` 和 `ACCESSES_RESOURCE` 关系。

### 5.2 与现有脚本的一致性

- 可以将当前 `neo4j_load_open_card.py` 抽象为一个可复用的模块，将 SAMPLE_DATA 替换为从数据库读出的对应结构。
- 同步服务的 Cypher 片段应与当前脚本保持一致：

  - `Business` 节点字段完全一致；
  - `Step` 使用 `step.step_id`；
  - `Implementation` 使用表中配置好的 `impl_id` + 其他属性；
  - `DataResource` 的属性列表与脚本一致；
  - 关系类型及属性名不变。

### 5.3 触发策略

- 一期可以采用手动触发：
  - 管理后台提供“发布到图谱”按钮；
  - 或命令行脚本：`python -m tools.sync_process c_open_card`。
- 后续可改为事件驱动/定时同步。

---

## 6. 前端应用设计（管理端 + 问答端）

### 6.1 设计原则

- **单一 Vue 应用，双布局**：
  - 一个前端项目 `frontend/`，通过路由区分：
    - `/admin/*`：管理后台（AdminLayout）；
    - `/qa`：业务问答入口（QaLayout）。
- **不直接操作 Neo4j**：所有写入都通过后端 API 落盘 MySQL，再由同步服务更新图谱.
- **字段对齐**：前端页面只编辑设计文档中已定义的表字段，不新增业务字段.

### 6.2 路由与布局结构

- 路由划分：
  - `/qa` → 问答端主页（默认从 `/` 重定向至 `/qa`）。
  - `/admin/processes` → 流程列表页.
  - `/admin/processes/:processId` → 流程编辑页.
  - `/admin/steps` → 步骤与实现管理页.
  - `/admin/data-resources` → 数据资源管理页.
  - `/admin/skeleton` → 数据采集与骨架生成页.

- 布局组件：
  - `AdminLayout`：
    - 左侧侧边栏：导航菜单（流程管理 / 步骤管理 / 数据资源 / 骨架生成 / 返回问答）。
    - 右侧内容区：`<router-view />` 承载具体管理页面.
  - `QaLayout`：
    - 顶部：标题 + 返回管理后台入口.
    - 主区：`<router-view />` 承载问答页.

### 6.3 管理端页面设计

#### 6.3.1 流程列表页（/admin/processes）

- 功能：
  - 展示所有业务流程的基本信息；
  - 支持新建、编辑、发布（同步到图谱）。
- 主要字段：
  - `process_id`, `name`, `channel`, `description`, `updated_at`.
- 典型交互：
  - 点击“新建流程” → 打开空白编辑页；
  - 点击某一行 → 跳转到 `/admin/processes/{process_id}`；
  - 点击“发布到图谱”按钮 → 调用 `POST /processes/{process_id}/publish`，完成 Neo4j 同步.
- 组件建议：
  - 表格组件（后续可接入 Element Plus 的 `el-table`）；
  - 顶部工具栏（按钮：新建 / 刷新）。

#### 6.3.2 流程编辑页（/admin/processes/:processId）

- 布局：
  - 顶部：流程基本信息表单：`name`, `channel`, `description`, `entrypoints`；
  - 下方左右分栏：
    - 左侧：步骤列表（按 `order_no` 排序）；
    - 右侧：步骤详情表单.
- 步骤列表：
  - 与 `business_step` 对应，每一行字段：
    - `order_no`, `step_id`, `step_name`（展示用，来自 `step.name`）；
  - 支持：
    - 通过拖拽或按钮调整顺序（更新 `order_no`）；
    - 选择一行，在右侧加载详情.
- 步骤详情表单：
  - 右侧区域主要用于展示当前所选步骤的基础信息（来自 `step`），以及跳转到 `/admin/steps` 对该步骤进行更深入编辑；流程编辑页本身只负责步骤顺序与引用关系，不修改 `step` 的自身属性。
- 后端交互：
  - `GET /processes/{process_id}`：加载基本信息；
  - `GET /processes/{process_id}/steps`：加载步骤列表；
  - `PUT /processes/{process_id}`：保存基本信息；
  - `PUT /processes/{process_id}/steps`：批量保存步骤配置.

#### 6.3.3 步骤与实现管理页（/admin/steps）

- 功能：维护 `step` 与其 `implementation` 列表的关系.
- 页面结构：
  - 左侧：步骤列表（`step_id`, `name`, `step_type`）；
  - 右侧：步骤详情 + 该步骤下的实现列表（基于 `step_implementation`）。
- 后端交互：
  - `GET /steps`；
  - `POST /steps` / `PUT /steps/{step_id}`；
  - `GET /steps/{step_id}/implementations` / `PUT /steps/{step_id}/implementations`.

#### 6.3.4 数据资源管理页（/admin/data-resources）

- 功能：维护 `data_resource` 和 `implementation_dataresource`.
- 页面结构：
  - 列表：`resource_id`, `name`, `type`, `system`, `description`；
  - 详情：展示哪些 `impl_id` 以何种 `access_type` 访问该资源（基于 `implementation_dataresource`）。
- 后端交互：
  - `GET /data-resources` / `POST /data-resources` / `PUT /data-resources/{resource_id}`；
  - `GET /data-resources/{resource_id}/accessors`（返回实现及其访问方式）。

#### 6.3.5 骨架生成页（/admin/skeleton）

- 功能：
  - 接收一批原始数据（如 curl 脚本、HTTP 抓包、日志片段、trace）和简要业务描述；
  - 调用后端骨架生成 API，获取候选流程骨架；
  - 在画布或列表上预览骨架（business + steps + business_step），支持简单编辑；
  - 用户确认后，一键写入正式配置（7 张表）并可选择立即同步到图谱。
- 页面结构（MVP）：
  - 左侧：
    - 文本区域：粘贴原始数据；
    - 输入框：简要业务描述（如“C 端开通月卡”）；
    - 按钮："生成骨架"（调用 `POST /skeleton/preview`）。
  - 右侧：
    - 流程骨架预览：按顺序展示步骤及其名称；
    - 可选：简单编辑能力（修改步骤名称、顺序，增删步骤）；
    - 按钮："保存为正式流程"（调用 `POST /skeleton/confirm`）。
- 后端交互：
  - `POST /skeleton/preview`：
    - 请求体：`{ description, raw_data }`；
    - 返回：候选骨架结构，形态接近 7 张表的子集（business + step + business_step），仅用于前端展示，不直接入库。
  - `POST /skeleton/confirm`：
    - 请求体：前端在预览基础上调整后的结构化骨架（与 7 张表字段对齐）；
    - 行为：写入 `business` / `step` / `business_step` 等表；必要时触发 `sync_process(process_id)`。

### 6.4 问答端页面设计（/qa）

#### 6.4.1 问答首页

- 布局：
  - 顶部：流程选择 + 简要说明（当前问答针对哪条业务流程）。
  - 左侧：聊天窗口；
  - 右侧（可选）：当前流程结构摘要（步骤列表 + 涉及系统/数据资源）。
- 关键组件：
  - `ProcessSelector`：
    - 下拉或搜索框，调用 `GET /processes` 获取 `process_id`/`name`；
    - 选择后将 `process_id` 传入问答请求.
  - `ChatWindow`：
    - 消息列表（用户提问 / AI 回答）；
    - 文本输入框 + 发送按钮，发送时禁用按钮并展示 loading 状态.
- 后端交互：
  - `GET /processes`：用于流程选择；
  - `POST /chat`：请求体 `{ question, process_id }`，返回 `{ answer, process_id }`；
  - （可选）`GET /graph/processes/{process_id}/context`：右侧显示流程结构.

> 问答端前期只做“单轮/多轮问答 + 可选的流程结构展示”，不在前端直接暴露节点 ID 或内部系统表名，由后端和 LLM 控制输出风格.

### 6.5 前端工程结构与分层约定

为保证前端实现风格统一、职责清晰，`frontend/` 采用如下目录结构与分层方式（示意）：

```text
frontend/
  src/
    main.ts            # 应用入口，注册 Router、全局组件等
    router/
      index.ts         # 定义所有路由（/qa、/admin/* 等）
    layouts/
      AdminLayout.vue  # 管理端布局
      QaLayout.vue     # 问答端布局
    views/
      admin/
        processes/     # 流程列表与编辑相关页面
        steps/         # 步骤与实现管理页面
        data-resources/# 数据资源管理页面
        skeleton/      # 骨架生成页面（/admin/skeleton）
      qa/
        Chat.vue       # 问答主页面
    components/        # 可复用 UI 组件（表格、表单片段、对话框等）
    api/               # HTTP API 封装（axios 实例 + 各业务模块接口）
      http.ts          # axios 实例配置（baseURL、拦截器等）
      processes.ts     # /processes 相关接口调用
      steps.ts         # /steps 相关接口调用
      data-resources.ts# /data-resources 相关接口调用
      skeleton.ts      # /skeleton 相关接口调用
      chat.ts          # /chat 相关接口调用
    composables/       # 组合式函数（业务逻辑与状态管理）
      useProcess.ts    # 流程列表/编辑的前端业务逻辑
      useSteps.ts      # 步骤与实现管理前端逻辑
      useDataResource.ts# 数据资源管理逻辑
      useSkeleton.ts   # 骨架生成页面逻辑
      useChat.ts       # 问答逻辑
    types/             # 前端类型定义（与后端 DTO 对齐）
```

分层职责约定：

- **views/**
  - 只负责页面布局与交互编排（事件绑定、调用 composables）；
  - 不直接调用 `axios`，一律通过 `api/*` 或 `composables/*` 间接调用后端；
- **layouts/**
  - 只负责顶层布局（导航、页头、内容区域），不写具体业务逻辑；
- **components/**
  - 纯展示或弱业务组件，可被多个页面复用；
  - 不直接访问 HTTP，只通过 props/emit 与外部交互；
- **api/**
  - 统一封装 HTTP 请求，暴露清晰的函数（如 `listProcesses`, `getProcess`, `publishProcess` 等）；
  - 负责与后端返回格式对齐，必要时在这里做字段命名转换；
  - 不持久化状态；
- **composables/**
  - 封装页面级/领域级的前端业务逻辑与状态（如 loading/error、表单数据、分页等）；
  - 内部调用 `api/*`，对外暴露 `useXxx()` 钩子；
  - 允许在多个页面之间复用逻辑；
- **router/**
  - 集中定义所有路由与布局映射；
  - 不写业务逻辑，只负责页面切换和守卫（如简单的权限/环境判断）。

技术栈约定：

- Vue 3 + `<script setup>` 风格；
- HTTP 统一使用 `axios`（封装在 `api/http.ts` 中）；
- 一期可只用原生 HTML/CSS + 少量自定义组件，后续如引入 Element Plus / AntV X6 等库，再在文档中追加具体组件选型说明。

---

## 7. 图谱访问 API 与 AI 问答服务

### 7.1 图谱访问 API

- `GET /processes/{process_id}/context`
  - 返回结构类似当前 `ask_ai_open_card.fetch_process_context`：
  - 包含：
    - `process`：Business 节点属性；
    - `steps`：按顺序排列的 Step，附带其 Implementations 与 DataResources 访问信息。

- API 内部查询逻辑：
  - MATCH `(:Business {process_id})-[:START_AT]->(start:Step)`；
  - 沿 `[:NEXT {process_id}]` 找出一条最长路径；
  - 对路径上的每个 Step：
    - OPTIONAL MATCH `(:Step)-[:EXECUTED_BY]->(:Implementation)`；
    - OPTIONAL MATCH `(:Implementation)-[:ACCESSES_RESOURCE]->(:DataResource)`。

### 7.2 AI 问答服务（复用 PoC 思路）

- 核心流程：
  1. 接收问题 + 可选 `process_id`（如未提供，可通过关键字/检索确定）；
  2. 调用 Graph API 获取流程上下文 JSON；
  3. 拼装系统提示词和 JSON 上下文，调用 LLM；
  4. 以业务视角输出“流程怎么走、有哪些系统、哪些关键数据资源”。

- 与现有 `ask_ai_open_card.py` 的差异：
  - 将脚本中的 `fetch_process_context` 与 `build_system_message` 提炼为服务层逻辑；
  - 不再在代码中硬编码 `process_id = "c_open_card"`，而是通过参数指定。

---

## 8. 一期实施建议

在完全保留当前图模型字段的前提下，一期可以按如下顺序推进：

1. **落地关系型表结构**
   - 按第 4 章设计在 MySQL 中创建 `business`、`step`、`business_step`、`implementation`、`step_implementation`、`data_resource`、`implementation_dataresource` 等表；
   - 将当前 SAMPLE_DATA 的内容通过一次性迁移脚本转换为上述表数据。

2. **实现图谱同步服务**
   - 抽象 `neo4j_load_open_card` 中的 Cypher 写入逻辑为通用模块；
   - 实现 `sync_process(process_id)`，从数据库读取数据后重建对应子图。

3. **实现基础 Graph API**
   - 至少提供 `GET /processes/{process_id}/context`；
   - 直接复用当前 Cypher 查询逻辑。

4. **服务化 AI 问答能力**
   - 将 `ask_ai_open_card` 中的对话逻辑封装为 HTTP 服务；
   - 支持指定 `process_id` 的问答场景。

5. **管理前端 MVP**
   - 先做表单式的流程/步骤/实现/资源管理和基本问答界面；
   - 后续再逐步演进为画布式编辑体验和更丰富的问答侧边栏信息。

## 9. 后端服务架构设计（FastAPI）

### 9.1 整体形态

- 单体 FastAPI 应用，按照职责拆分为：
  - API 层（路由）：处理 HTTP 请求、参数校验、返回 DTO；
  - Service 层：封装业务用例（配置管理、同步、查询、问答）；
  - Infra 层：MySQL / Neo4j / LLM 客户端与配置管理。

### 9.2 模块与目录规划

以 `backend/` 为根目录，整体结构示意：

```text
backend/
  app/
    main.py              # FastAPI 应用入口，挂载各 router
    api/
      v1/
        processes.py     # 业务流程 & business_step 配置 CRUD + 发布
        steps.py         # step & step_implementation 配置 CRUD
        data_resources.py# 数据资源 & implementation_dataresource 配置
        graph.py         # 图谱查询（process context 等）
        chat.py          # AI 问答接口
        skeleton.py      # 数据采集与流程骨架生成接口
    services/
      process_service.py       # 操作 business / business_step
      step_service.py          # 操作 step / step_implementation
      data_resource_service.py # 操作 data_resource / implementation_dataresource
      graph_sync_service.py    # sync_process(process_id) → 写 Neo4j
      graph_query_service.py   # 从 Neo4j 读取流程子图
      chat_service.py          # 调用 graph_query + LLM 生成答案
      skeleton_service.py      # 数据采集与骨架生成（不持久化原始数据）
    models/             # ORM 模型（与第 4 章表结构对齐）
    schemas/            # Pydantic 模型（API 入参/出参 DTO）
    db/
      mysql.py          # SQLAlchemy 会话管理
      neo4j.py          # Neo4j driver 封装
    llm/
      client.py         # LLM 客户端封装（api_key / base_url / model）
    core/
      config.py         # 配置加载（环境变量）
      logging.py        # 日志配置
```

### 9.3 关键模块职责

- **API 层（app/api/v1）**
  - `processes.py`：
    - 提供 `/processes` 系列接口：列表、详情、流程步骤查询与保存；
    - 提供 `/processes/{process_id}/publish` 接口，调用 `graph_sync_service.sync_process`。
  - `steps.py`：
    - 提供 `/steps` 与 `/steps/{step_id}/implementations` 等接口；
    - 负责步骤定义与实现绑定（基于 `step_implementation`）的增删改查。
  - `data_resources.py`：
    - 提供 `/data-resources` 与 `/data-resources/{resource_id}/accessors` 接口；
    - 负责数据资源与实现访问关系（基于 `implementation_dataresource`）管理。
  - `skeleton.py`：
    - 提供 `/skeleton/preview` 与 `/skeleton/confirm` 接口；
    - 前者只在内存中处理原始数据并返回候选流程骨架，不写入数据库；
    - 后者接收前端确认后的结构化骨架，写入 7 张表并可选触发图谱同步。
  - `graph.py`：
    - 提供 `GET /graph/processes/{process_id}/context` 接口；
    - 内部调用 `graph_query_service.get_process_context`。
  - `chat.py`：
    - 提供 `POST /chat` 接口；
    - 内部调用 `chat_service.answer(question, process_id)`。

- **Service 层（app/services）**
  - `process_service.py`：
    - 封装对 `business` 和 `business_step` 的所有读写；
    - 提供按 `process_id` 加载完整流程配置的能力，供同步和前端使用。
  - `step_service.py` / `data_resource_service.py`：
    - 分别封装步骤（含 `step_implementation`）与数据资源（含 `implementation_dataresource`）相关的表操作。
  - `skeleton_service.py`：
    - 对外提供 `generate_skeleton_preview(description, raw_data)` 和 `save_skeleton(structured_skeleton)` 等方法；
    - 内部协调 LLM 调用，将原始数据转换为接近 7 张表结构的中间表示；
    - 严格保证不持久化原始数据，只写入用户确认后的结构化骨架。
  - `graph_sync_service.py`：
    - 面向 API 暴露 `sync_process(process_id)`；
    - 内部从各 service 读取配置，按第 5 章描述的逻辑写入 Neo4j。
  - `graph_query_service.py`：
    - 面向 API 和 `chat_service` 暴露 `get_process_context(process_id)`；
    - 使用与 PoC 中 `fetch_process_context` 等价的 Cypher 查询。
  - `chat_service.py`：
    - 负责组装 LLM prompt，协调调用 `graph_query_service` 与 `llm.client`；
    - 保证对外回答风格满足“面向业务，不暴露内部 ID/表名”的约束。

- **Infra 层（db / llm / core）**
  - `db/mysql.py`：管理 SQLAlchemy engine 和 Session，提供依赖注入；
  - `db/neo4j.py`：统一创建与关闭 Neo4j driver；
  - `llm/client.py`：封装对外部 LLM 接口（如 OpenAI 协议兼容网关）的访问；
  - `core/config.py`：加载 MySQL/Neo4j/LLM 等配置，避免散落硬编码；
  - `core/logging.py`：统一日志格式与等级。

### 9.4 分层依赖与调用链约束

为保证后端可维护性与一致性，约定各层之间的**依赖方向**与**调用链**如下：

- 依赖方向（只能“往下”依赖，不允许反向引用）：
  - `api/v1/*` → `schemas/*` → `services/*` → `models/*` → `db/*`
  - `services/*` 可以依赖：`models/*`, `db/*`, `llm/*`, `core/*`
  - `graph_*_service.py` 还可以依赖 `db/neo4j.py`
  - `chat_service.py` / `skeleton_service.py` 可以依赖 `llm/client.py`

- 调用链示例：
  - 配置 CRUD：
    - `processes.py` 接收 HTTP 请求，使用 `schemas` 校验入参/出参；
    - 调用 `process_service` 完成业务逻辑与数据库读写；
    - `process_service` 通过 ORM 模型 `models/*` 与 `db/mysql.py` 交互。
  - 图谱查询：
    - `graph.py` 调用 `graph_query_service.get_process_context`；
    - `graph_query_service` 通过 `db/neo4j.py` 执行 Cypher 查询。
  - 问答与骨架生成：
    - `chat.py` / `skeleton.py` 调用各自的 service；
    - service 内部先通过 `graph_query_service` / `db` 获取结构化上下文，再通过 `llm/client.py` 调用 LLM。

- 约束与建议：
  - **API 层**不直接访问数据库或 LLM，只调用 Service；
  - **Service 层**不依赖 FastAPI 的 `Request`/`Response` 等对象，保持为纯业务逻辑，便于单元测试；
  - **models/** 只负责 ORM 映射，不包含业务逻辑；
  - **schemas/** 只负责请求/响应 DTO，与 ORM 模型解耦；
  - 所有对外部系统（MySQL / Neo4j / LLM）的访问，都集中在 `db/*` 与 `llm/client.py` 中，避免散落硬编码。

---

> 本设计文档的所有方案均以当前 Neo4j 图模型为唯一基准，不新增任何节点字段。
> 后续如需增加版本、状态等元数据，建议优先在关系型数据库层扩展字段，再视需要决定是否投影到图层，并在本设计文档中追加相应章节。
