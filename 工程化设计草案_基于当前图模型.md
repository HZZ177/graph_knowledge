# 工程化设计草案（基于当前图模型）

> 本文档严格以当前 `test/neo4j_load_open_card.py` 中的图模型为基准，不擅自增加新的节点类型或字段，仅在此基础上讨论工程化落地方案。

---

## 1. 目标与范围

### 1.1 目标

围绕当前 Neo4j 图模型中已有的四类节点与关系：

- 节点标签：
  - `Business`  （属性：`process_id`, `name`, `channel`, `description`, `entrypoints`）
  - `Step`      （属性：`step_id`, `name`, `description`, `step_type`）
  - `Implementation`（属性：`impl_id`, `name`, `type`, `system`, `description`, `code_ref`）
  - `DataResource`  （属性：`resource_id`, `name`, `type`, `system`, `description`）
- 关系：
  - `(:Business)-[:START_AT]->(:Step)`
  - `(:Step)-[:NEXT {process_id}]->(:Step)`
  - `(:Step)-[:EXECUTED_BY]->(:Implementation)`
  - `(:Implementation)-[:ACCESSES_RESOURCE {access_type, access_pattern}]->(:DataResource)`

在**不扩展字段的前提下**，完成一份工程化方案草案，目标包括：

- 支持多条业务流程的配置与管理（不只 `c_open_card`）。
- 以关系型数据库（如 MySQL）为**主数据源**，与当前图模型保持字段一一对应。
- 通过同步服务将主数据投影为 Neo4j 图视图，维持与现有节点/关系模型完全一致。
- 搭建一个基础的管理前端和 AI 问答服务，演示从“配置 → 图谱 → LLM”的闭环。

### 1.2 一期范围（MVP）

- 范围内：
  - 多个 `Business` 流程及其 `Step` 顺序（只考虑线性主链路 + 简单分支占位）。
  - 每个 `Step` 与一个或多个 `Implementation` 的绑定。
  - `Implementation` 与 `DataResource` 的访问关系（读/写模式描述）。
  - 一个简单的 Web/CLI 问答接口，调用 LLM 基于 `Business` 子图回答“这条流程怎么走、涉及哪些系统和资源”。
- 范围外（后续迭代）：
  - 更复杂的错误模式、版本灰度、权限模型等。

---

## 2. 当前图模型回顾

本小节仅做事实性描述，严格对应 `neo4j_load_open_card.py` 中的写入逻辑。

### 2.1 SAMPLE_DATA 结构

当前脚本中的配置来源为 `SAMPLE_DATA: Dict[str, List[Dict[str, Any]]]`，包含：

- `"business_processes"`：业务流程列表
  - 字段：`process_id`, `name`, `channel`, `domain`, `description`, `entrypoints`
- `"business_process_steps"`：流程内步骤
  - 字段：`step_id`, `process_id`, `order_no`, `capability_id`, `name`, `branch`, `role`, `condition`, `is_optional?`
- `"business_capabilities"`：业务能力
  - 字段：`capability_id`, `domain`, `name`, `description`, `capability_type`
- `"data_resources"`：数据资源
  - 字段：`name`, `resource_id`, `type`, `system`, `location`, `entity_id`, `description`
- `"capability_implementations"`：能力的系统实现
  - 字段：`capability_id`, `system`, `entry_type`, `entry_name`, `code_ref`
- `"capability_data_access"`：能力对数据资源的访问
  - 字段：`capability_id`, `resource_id`, `access_type`, `access_pattern`

> 说明：`domain`, `location`, `entity_id` 等字段存在于 SAMPLE_DATA 中，但在当前图模型中**没有写入节点/关系属性**，仅作为配置来源。

### 2.2 写入 Neo4j 的节点与属性

根据 `load_*` 函数，实际写入 Neo4j 的结构为：

- `(:Business {process_id, name, channel, description, entrypoints})`
  - 唯一约束：`Business(process_id)`
- `(:Step {step_id, name, description, step_type})`
  - `step_id` = `capability_id`（来自 `business_capabilities`）
  - 唯一约束：`Step(step_id)`
- `(:Implementation {impl_id, name, type, system, description, code_ref})`
  - `impl_id` 为脚本内部生成（如 `impl_1`, `impl_2` ...）
  - 唯一约束：`Implementation(impl_id)`
- `(:DataResource {resource_id, name, type, system, description})`
  - `resource_id` 为如 `member_db.user_card`
  - 唯一约束：`DataResource(resource_id)`

### 2.3 写入 Neo4j 的关系与属性

- 流程起点：
  - `(:Business {process_id})-[:START_AT]->(:Step {step_id})`
- 步骤顺序（主链）：
  - `(:Step {step_id=from})-[:NEXT {process_id}]->(:Step {step_id=to})`
- 步骤与实现：
  - `(:Step {step_id=capability_id})-[:EXECUTED_BY]->(:Implementation {impl_id})`
- 实现与数据资源：
  - `(:Implementation {impl_id})-[:ACCESSES_RESOURCE {access_type, access_pattern}]->(:DataResource {resource_id})`

> 关键设计：当前版本中，**不再单独建 BusinessCapability 节点**，而是用 `capability_id` 作为 `Step.step_id`，并通过 `EXECUTED_BY` + `ACCESSES_RESOURCE` 间接承载“能力”的技术视图。

---

## 3. 工程化总体方案（保持图模型不变）

### 3.1 组件划分

在保持 Neo4j 中节点/关系/属性不变的前提下，引入以下组件：

- **配置存储层（MySQL 等）**
  - 以表结构 1:1 映射当前 SAMPLE_DATA 中的结构和字段。
  - 作为 `Business` / `Step` / `Implementation` / `DataResource` / `capability_data_access` 的主数据源。
- **图谱同步服务（Graph Sync Service）**
  - 从 MySQL 读取配置，生成与当前脚本完全相同的 Neo4j 图结构。
  - 保证图谱与主数据在字段和含义上严格一致。
- **图谱访问 API（Graph API Service）**
  - 封装常用查询：按 `process_id` 获取完整子图、列出流程、按 `resource_id` 反查流程等。
- **管理前端（Admin UI）**
  - 对 `Business`/`business_process_steps`/`capability_implementations`/`data_resources` 等进行可视化查看和编辑。
  - 提供简化版“流程画布”，但画布数据最终仍落盘为与 SAMPLE_DATA 对齐的结构。
- **AI 问答服务（AI Orchestrator）**
  - 基于 Graph API，从 Neo4j 取出 `Business` 子图，整理成 JSON 上下文，调用 LLM 生成业务描述性回答。

### 3.2 数据流概览

1. 管理前端/配置脚本 → 写入/更新 MySQL 表（结构对齐 SAMPLE_DATA）。
2. 图谱同步服务监听配置变更或被手动触发，执行：
   - 按 `process_id` 从 MySQL 拉取完整配置；
   - 在 Neo4j 中清理该 `process_id` 对应子图（可选策略）；
   - 以当前 `neo4j_load_open_card.py` 的逻辑为模板，重建 `Business`/`Step`/`Implementation`/`DataResource` 节点和关系。
3. AI 问答服务通过 Graph API 查询：
   - `Business(process_id)` 及其 `START_AT` + `NEXT` 路径上的 `Step`；
   - 每个 `Step` 的 `EXECUTED_BY` 实现和 `ACCESSES_RESOURCE` 关系；
   - 生成结构化上下文并调用 LLM。

---

## 4. 关系型数据库映射设计（严格对齐现有字段）

本节的表结构只保留当前图写入和同步逻辑实际需要的字段，不额外增加业务字段，仅适当补充技术性主键/时间戳字段（如 `id`, `created_at`, `updated_at`），且这些技术字段不会映射到 Neo4j。

### 4.1 业务流程配置

- **`business_process`**（对应 `SAMPLE_DATA["business_processes"]`）

  - `id` (PK，自增，用于内部管理，不映射到图)
  - `process_id` (string, unique)  —— 对应 Business.process_id
  - `name` (string)                —— 对应 Business.name
  - `channel` (string)             —— 对应 Business.channel
  - `description` (string)         —— 对应 Business.description
  - `entrypoints` (json/text)      —— 对应 Business.entrypoints
  - `created_at`, `updated_at`     —— 技术字段

- **`business_process_step`**（对应 `SAMPLE_DATA["business_process_steps"]`）

  - `id` (PK，自增，用于内部管理，不映射到图)
  - `process_id` (string, FK → business_process.process_id)
  - `order_no` (int)
  - `capability_id` (string)       —— 在图中将被用作 Step.step_id
  - `name` (string)                —— 用于 Step.name
  - `branch` (string)
  - `role` (string)
  - `condition` (string, nullable)
  - `is_optional` (bool, nullable)
  - `created_at`, `updated_at`

> 图模型中 `Step.step_id` 直接使用 `capability_id`，`order_no` 只作为构建 `NEXT` 链路的配置信息，**不直接映射为图属性**。

### 4.2 业务能力与实现

在当前图模型中，`BusinessCapability` 节点未被写入图中，但 SAMPLE_DATA 中仍存在 `business_capabilities` 与 `capability_implementations`。在工程化方案中：

- 关系型数据库仍然保留这两类配置表；
- Neo4j 图层只使用其中部分字段：
  - 从 `business_capabilities` 读取 `capability_id`, `name`, `description`, `capability_type` 用于构造 `Step` 节点属性；
  - 从 `capability_implementations` 生成 `Implementation` 节点和与 `Step` 的 `EXECUTED_BY` 关系。

#### 4.2.1 `business_capability`（对应 `SAMPLE_DATA["business_capabilities"]`）

- `id` (PK，自增)
- `capability_id` (string, unique)
- `name` (string)
- `description` (string)
- `capability_type` (string)  —— 将映射为 Step.step_type
- `created_at`, `updated_at`

> 这些字段是当前图写入逻辑实际使用的字段；图层使用其中：`capability_id`, `name`, `description`, `capability_type`。

#### 4.2.2 `capability_implementation`（对应 `SAMPLE_DATA["capability_implementations"]`）

- `id` (PK，自增)
- `capability_id` (string, FK → business_capability.capability_id)
- `system` (string)
- `entry_type` (string)      —— 映射为 Implementation.type
- `entry_name` (string)      —— 映射为 Implementation.name
- `code_ref` (string)        —— 映射为 Implementation.code_ref
- `created_at`, `updated_at`

> 图层会基于这些记录生成 Implementation 节点：
>
> - `impl_id`：在同步时生成，如 `"impl_" || id` 或其他稳定规则
> - 其他属性一一对应。

### 4.3 数据资源与访问关系

#### 4.3.1 `data_resource`（对应 `SAMPLE_DATA["data_resources"]`）

- `id` (PK，自增)
- `name` (string)
- `resource_id` (string, unique)  —— 映射为 DataResource.resource_id
- `type` (string)                 —— 映射为 DataResource.type
- `system` (string)               —— 映射为 DataResource.system
- `description` (string)          —— 映射为 DataResource.description
- `created_at`, `updated_at`

> 图层仅使用：`resource_id`, `name`, `type`, `system`, `description`，与当前脚本完全一致。

#### 4.3.2 `capability_data_access`（对应 `SAMPLE_DATA["capability_data_access"]`）

- `id` (PK，自增)
- `capability_id` (string, FK → business_capability.capability_id)
- `resource_id` (string, FK → data_resource.resource_id)
- `access_type` (string)
- `access_pattern` (string)
- `created_at`, `updated_at`

> 图层会用这些记录，在 `(Implementation)` 与 `(DataResource)` 之间创建 `ACCESSES_RESOURCE` 关系，属性：`access_type`, `access_pattern`。

---

## 5. 图谱同步服务设计

### 5.1 同步接口

提供一个按流程粒度的同步接口，例如：

- `sync_process(process_id: str) -> None`

行为：

1. 从 MySQL 中读取：
   - 该 `process_id` 的 `business_process` 记录；
   - 对应的 `business_process_step` 列表；
   - 所有相关的 `business_capability` / `capability_implementation` / `capability_data_access` / `data_resource`。
2. 在 Neo4j 中：
   - 可选：删除该 `process_id` 相关的 `Business` 节点及其关联子图（避免脏数据）。
   - 按当前 `neo4j_load_open_card.py` 逻辑依次执行：
     - 创建 `Business` 节点；
     - 创建 `Step` 节点，并根据 `order_no` 构建一条 `START_AT` + `NEXT` 链路；
     - 创建 `DataResource` 节点；
     - 创建 `Implementation` 节点；
     - 建立 `EXECUTED_BY` 和 `ACCESSES_RESOURCE` 关系。

### 5.2 与现有脚本的一致性

- 可以将当前 `neo4j_load_open_card.py` 抽象为一个可复用的模块，将 SAMPLE_DATA 替换为从数据库读出的对应结构。
- 同步服务的 Cypher 片段应与当前脚本保持一致：

  - `Business` 节点字段完全一致；
  - `Step` 使用 `capability_id` 作为 `step_id`；
  - `Implementation` 使用生成的 `impl_id` + 与 entry/系统字段对齐；
  - `DataResource` 的属性列表与脚本一致；
  - 关系类型及属性名不变。

### 5.3 触发策略

- 一期可以采用手动触发：
  - 管理后台提供“发布到图谱”按钮；
  - 或命令行脚本：`python -m tools.sync_process c_open_card`。
- 后续可改为事件驱动/定时同步。

---

## 6. 管理前端与编辑体验

### 6.1 设计原则

- **不直接操作 Neo4j**：前端所有编辑均落盘到 MySQL 表中，由同步服务负责更新图谱。
- **表结构与图模型一一对应**：前端只暴露与当前字段集一致的信息，不在界面层新增额外业务属性。

### 6.2 核心页面

- **流程列表页**
  - 展示 `business_process`：`process_id`, `name`, `channel`, `domain`, `description`；
  - 操作：新建、复制、编辑、发布（触发 sync）。

- **流程步骤编辑页（可视画布简化版）**
  - 中间：线性步骤列表/画布，对应 `business_process_step` 的 `order_no` 序列；
  - 左侧：可选能力列表（来自 `business_capability`），选中后填充 `capability_id` 和默认 `name`；
  - 右侧：步骤属性表单（`name`, `branch`, `role`, `condition`, `is_optional`）。

- **实现与数据资源管理页**
  - `capability_implementation` 管理：维护 `system`, `entry_type`, `entry_name`, `code_ref`；
  - `data_resource` 管理：维护 `resource_id`, `name`, `type`, `system`, `description`；
  - `capability_data_access` 管理：建立 `capability_id` 与 `resource_id` 的访问关系及模式说明。

> 画布中的“连线”在当前图模型里仅体现在 `NEXT` 关系，且由 `order_no` 推导。一期可以不做复杂分支编辑，仅用顺序 + 简单 branch 字段表示主链路。

---

## 7. 图谱访问 API 与 AI 问答服务

### 7.1 图谱访问 API

- `GET /processes/{process_id}/context`
  - 返回结构类似当前 `ask_ai_open_card.fetch_process_context`：
  - 包含：
    - `process`：Business 节点属性；
    - `steps`：按顺序排列的 Step，附带其 Implementations 与 DataResources 访问信息。

- API 内部查询逻辑：
  - MATCH `(:Business {process_id})-[:START_AT]->(start:Step)`；
  - 沿 `[:NEXT {process_id}]` 找出一条最长路径；
  - 对路径上的每个 Step：
    - OPTIONAL MATCH `(:Step)-[:EXECUTED_BY]->(:Implementation)`；
    - OPTIONAL MATCH `(:Implementation)-[:ACCESSES_RESOURCE]->(:DataResource)`。

### 7.2 AI 问答服务（复用 PoC 思路）

- 核心流程：
  1. 接收问题 + 可选 `process_id`（如未提供，可通过关键字/检索确定）；
  2. 调用 Graph API 获取流程上下文 JSON；
  3. 拼装系统提示词和 JSON 上下文，调用 LLM；
  4. 以业务视角输出“流程怎么走、有哪些系统、哪些关键数据资源”。

- 与现有 `ask_ai_open_card.py` 的差异：
  - 将脚本中的 `fetch_process_context` 与 `build_system_message` 提炼为服务层逻辑；
  - 不再在代码中硬编码 `process_id = "c_open_card"`，而是通过参数指定。

---

## 8. 一期实施建议

在完全保留当前图模型字段的前提下，一期可以按如下顺序推进：

1. **落地关系型表结构**
   - 按第 4 章设计在 MySQL 中创建 `business_process`、`business_process_step`、`business_capability`、`capability_implementation`、`data_resource`、`capability_data_access` 等表；
   - 将当前 SAMPLE_DATA 的内容迁移为表数据。

2. **实现图谱同步服务**
   - 抽象 `neo4j_load_open_card` 中的 Cypher 写入逻辑为通用模块；
   - 实现 `sync_process(process_id)`，从数据库读取数据后重建对应子图。

3. **实现基础 Graph API**
   - 至少提供 `GET /processes/{process_id}/context`；
   - 直接复用当前 Cypher 查询逻辑。

4. **服务化 AI 问答能力**
   - 将 `ask_ai_open_card` 中的对话逻辑封装为 HTTP 服务；
   - 支持指定 `process_id` 的问答场景。

5. **管理前端 MVP**
   - 先做表单式的流程/步骤/实现/资源管理；
   - 后续再逐步演进为画布式编辑体验。

---

> 本草案的所有设计均以当前 Neo4j 图模型为唯一基准，不新增任何节点字段。
> 后续如需增加版本、状态等元数据，建议优先在关系型数据库层扩展字段，再视需要决定是否投影到图层。
